---
title: "Case study A: Exploring scRNA-seq data from 5 cancer cell lines with scBubbletree"
author: "SK"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---


```{r, echo = F}
source(file = "~/Rutil/Init_Rpack.R")
source(file = "~/Rutil/Graphics.R")
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = F,
                      comment = F, 
                      warning = F, 
                      message = F)
```


This vignette introduces `scBubbletree`, a transparent workflow for exploration
of single cell RNA-seq data. To run this vignette we need a few R-packages:


```{r, echo = T, eval = F, results='hide'}
library(scBubbletree)
library(Seurat)
library(ggrepel)
```


```{r, echo = F, results='hide'}
library(scBubbletree)
library(Seurat, lib.loc = lib.loc)
library(ggrepel, lib.loc = lib.loc)
```


```{r, echo=F}
redo_case_a <- F
```





## Data[^1]

Here we will analyze a scRNA-seq dataset containing a mixture of 3,918 cells 
from five human lung adenocarcinoma cell lines (HCC827, H1975, A549, H838 and 
H2228). The dataset is available here[^2].
  
The library was prepared with 10x Chromium platform and sequencing was 
performed with Illumina NextSeq 500 platform. Raw data was processed with 
Cellranger. The tool demuxlet was used to predict the identity of each cell 
based on known genetic differences between the different cell lines. 

```{r, echo=T, eval = F, results='hide'}
# create directory
dir.create(path = "case_study_A/")


# download the data from: 
https://github.com/LuyiTian/sc_mixology/raw/master/data/sincell_with_class_5cl.RData


# load the data
load(file = "case_study_A/sincell_with_class_5cl.RData")


# we are only interested in the 10x data object 'sce_sc_10x_5cl_qc'
d <- sce_sc_10x_5cl_qc


# remove the remaining objects (cleanup)
rm(sc_Celseq2_5cl_p1, sc_Celseq2_5cl_p2, sc_Celseq2_5cl_p3, sce_sc_10x_5cl_qc)


# get the meta data for each cell
meta <- colData(d)[, c("cell_line_demuxlet", "non_mt_percent", "total_features")]


# create Seurat object from the raw counts and append the meta data to it
d <- Seurat::CreateSeuratObject(counts = d@assays$data$counts,
                                project = '')


# check if all cells are matched between d and meta
# table(rownames(d@meta.data) == meta@rownames)
d@meta.data <- cbind(d@meta.data, meta@listData)


# cell type predictions are provided as part of the meta data
table(d@meta.data$cell_line)


# select 5,000 most variable genes
d <- Seurat::FindVariableFeatures(object = d,
                                  selection.method = "vst",
                                  nfeatures = 5000)

# Preprocessing with Seurat: SCT transformation + PCA + UMAP
d <- SCTransform(object = d,
                 variable.features.n = 5000)
d <- RunPCA(object = d, 
            npcs = 50,
            features = VariableFeatures(object = d))

d <- RunUMAP(d, dims = 1:15)
d <- RunTSNE(d, dims = 1:15)

save(d, file = "case_study_A/d.RData")
```


```{r}
# load Seurat object
d <- get(load(file = "case_study_A/d.RData"))
```






## scBubbletree
   
We will analyze this data with `scBubbletree`. 

As first input `scBubbletree` uses matrix $A^{n\times f}$ which represents a 
low-dimensional projection of the original scRNA-seq data, with $n$ rows as 
cells and $f$ columns as low-dimension features. 

We will use the PCA data generated by `Seurat` as $A$. In particular, we will 
use the first 15 principal components (PCs) as every additional PC explains 
negligible amount of variance in the data.

```{r, fig.width=4, fig.height=3, echo=T, fig.align='center'}
var_explained <- ((d[["pca"]]@stdev)^2)/d[["pca"]]@misc$total.variance

g_var_explained <- ggplot(data = data.frame(var_explained = var_explained*100,
                                            PC = 1:length(var_explained)))+
  geom_point(aes(y = var_explained, x = PC), size = 1)+
  ylab(label = "Variance explained [%]")

g_var_explained
```


```{r, fig.width=4, fig.height=3, echo = F, eval=F, results='hide'}
ggsave(plot = g_var_explained, 
       filename = "manuscript_data/Var_explained_PCA_A.pdf",
       device = "pdf",
       width = 3,
       height = 2)
```


```{r, echo = T}
# This is the main input of scBubbletree -> matrix A
A <- d@reductions$pca@cell.embeddings[, 1:15]


# A has n=cells as rows, f=features as columns (e.g. from PCA)
dim(A)
```




The `scBubbletree` workflow performs the following steps:
  
  1. determine number of clusters $k$
  2. $k$-means clustering
  3. hierarchical organization of clusters (bubbles)
  4. annotation and evaluation


### 1. determining the number of clusters $k$
How many clusters (cell types) are there are in the data? Can we guess a 
reasonable value of $k$? 

Two approaches should be used to find $k$. First, we need to study the 
literature or databases such as the human protein atlas database (HPA) to 
identify a reasonable range of $k$s. Second, we can use the function `get_k` 
for data-driven inference of $k$ based on the Gap statistic and the within-
cluster sum of squares (WCSS).

As this is a toy dataset, we will skip the first approach and perform a 
data-driven search for $k$ using `get_k` which performs $B$ bootstrapping 
iterations. k-means clustering is performed in each iteration using as input 
matrix $A$ an a vector of $k$ values. We can use the full matrix $A$ (this 
is recommended for smaller datasets) or a subset of the rows (cells) of $A$ 
controlled by the parameter `cv_prop` (recommended for large datasets). In 
each iteration we compute the Gap statistic and WCSS for all $k$s.
  
Lets run `get_k` now:

```{r, echo = T, eval = F}
b <- get_k(B = 10, 
           cv_prop = 1,
           ks = 1:20,
           x = A,
           n_start = 100, 
           iter_max = 200,
           kmeans_algorithm = "MacQueen", 
           cores = 20,
           mini_output = F)
```


```{r,  echo=F}

if(redo_case_a) {
  # Determine appropriate number of clusters (k)
  b <- get_k(B = 10, 
             cv_prop = 1,
             ks = 1:20,
             x = A,
             n_start = 100, 
             iter_max = 200,
             kmeans_algorithm = "MacQueen", 
             cores = 20,
             mini_output = F)
  
  if(dir.exists("case_study_A")==F) {
    dir.create("case_study_A")
  }
  save(b, file = "case_study_A/b.RData")
} else {
  b <- get(load("~/scBubbletree/case_study_A/b.RData"))
}

```

The Gap statistic and WCSS curves have a noticeable knee (elbow) at $k=5$. 
Hence, $k$=5 appears to be reasonable first choice of $k$. Means and 95% 
confidence intervals are shown for the metrics (panels) at each $k$.

```{r, echo=T, eval=T}
g0 <- ggplot(data = b$gap_stats_summary)+
  geom_point(aes(x = k, y = gap_mean), size = 1)+
  geom_errorbar(aes(x = k, y = gap_mean, ymin = L95, ymax = H95), width = 0.1)+
  ylab(label = "Gap")|
ggplot(data = b$wcss_stats_summary)+
  geom_point(aes(x = k, y = wcss_mean), size = 1)+
  geom_errorbar(aes(x = k, y = wcss_mean, ymin = L95, ymax = H95), width = 0.1)+
  ylab(label = "WCSS")+
  scale_y_log10()+
  annotation_logticks(base = 10, sides = "l")
```


```{r, fig.width=7, fig.height=2.5, fig.align='center', echo=T, eval=T}
g0
```


### 2. $k$-means clustering
Now that we found out that $k=5$ is reasonable we will perform clustering with
$k=5$ and $A$ as inputs. We use the function kmeans (R-package stats) which 
offers various k-means variants. Here we will use MacQueen's k-means variant, 
which will perform $n_{start} = 1000$ (default in scBubbletree) random starts 
and a maximum number of iterations $iter_{max} = 300$. 

**Important remark**: for smaller datasets (e.g. $n<100,000$) $n_{start} = 1000$ 
and $n_{iter} = 300$ are set to unnecessarily high defaults, however for larger
datasets this is necessary to make sure that k-means converges.


### 3. hierarchical grouping
After the clustering is complete we will organize the bubbles in a natural
hierarchy. For this we perform $B$ bootstrap iterations (default $B=100$). 
In iteration $b$ the algorithm draws a random subset of $N_{eff}$ (default 
$N_{eff}=100$) cells with replacement from each cluster and computes the 
average inter-cluster Euclidean distance. This data is used to populate the 
distance matrix ($D^{k\times k}_b$), which is provided as input for hierarchical
clustering with average linkage to generate a hierarchical clustering dendrogram
$H_b$. 

The collection of distance matrices that are computed during $B$ iterations are 
used to compute a consensus (average) distance matrix ($\hat{D}^{k\times k}$) 
and a corresponding consensus hierarchical dendrogram (bubbletree; $\hat{H}$). 
The collection of dendrograms are used to quantify the robustness of the 
bubbletree topology, i.e. to count the number of times each branch in the 
bubbletree is found among the topologies of the bootstrap dendrograms. Branches 
can have has variable degrees of support ranging between 0 (no support) and $B$ 
(complete support). Distances between bubbles (inter-bubble relationships) are 
described quantitatively in the bubbletree as sums of branch lengths. 

Steps 2. and 3. are performed next

```{r, echo=T, eval=F}
k5 <- get_bubbletree(x = A,
                       k = 5,
                       seed = 1234,
                       cores = 1,
                       B = 200,
                       N_eff = 200,
                       round_digits = 1,
                       show_simple_count = F,
                       kmeans_algorithm = "MacQueen")
```


```{r, echo=F}

if(redo_case_a) {
  
  k5 <- get_bubbletree(x = A,
                       k = 5,
                       seed = 1234,
                       cores = 1,
                       B = 200,
                       N_eff = 200,
                       round_digits = 1,
                       show_simple_count = F,
                       kmeans_algorithm = "MacQueen")
  
  if(dir.exists("case_study_A")==F) {
    dir.create("case_study_A")
  }
  save(k5, file = "case_study_A/k5.RData")
} else {
  k5 <- get(load("~/scBubbletree/case_study_A/k5.RData"))
}


```


... and plot the bubbletree

```{r, fig.width=4, fig.height=3, fig.align='center', echo=T}
k5$tree
```


Lets describe the bubbletree:

**bubbles**: The bubbletree has `k=5` bubbles (clusters) shown as leaves. The 
absolute and relative cell frequencies in each bubble and the bubble IDs are 
shown as labels. Bubble radii and color-code represent cell count in each 
bubble, i.e. large & dark bubbles have many cells and small & light bubbles 
contain few cells. 

Bubble 1 is the largest (and darkest) one in the dendrogram and contains 
1,253 cells ($\approx$ 32% of all cells in the dataset). Bubble 4 is the 
smallest one (and brightest) and contains only 436 cells ($\approx$ 11% of 
all cells in the dataset). 

We can access the bubble data shown in the bubbletree

```{r, echo=T, results=T}
knitr::kable(k5$tree_meta, digits = 2, row.names = F)
```

**topology**: inter-bubble distances are represented by sums of the corresponding 
branch lengths in the dendrogram. Branches of the bubbletree are annotated with 
their bootstrap support values (red branch labels). The branch support value 
tells us how many times a given branch from the bubbletree was found among the 
$B$ bootstrap dendrograms. We called `get_bubbletree` with $B=200$. All but one 
branch have complete (200 out of 200) support, and one branch has lower support 
of 179 (85%). This tells us that the branch between bubbles (3, 4) and 1 is not 
as robust.


### 4. annotation and evaluation
To extract biologically useful information from the bubbletree (and also for 2D 
UMAP or t-SNE plots) we need to adorn it with biologically relevant cell 
features. This includes both **numeric** and **categorical** cell features.

Numeric cell features:

  * gene expression
  * % of mitochondrial transcripts
  * number of UMIs, genes detected
  * ...

Categorical cell features:

  * cell type label (e.g. B-cells, T-cells, moncytes, ...)
  * cell cycle phase (e.g. S, M, G1, ...)
  * sample name (e.g. S1, S2, S3, ...)
  * treatment group (e.g. cancer vs. control cell)
  * multiplet status (e.g. singlet, doublet or multiplet)
  * ...


In the next two paragraph we will explain how to 'attach' numeric and 
categorical features to the bubbletree using `scBubbletree`.


### attaching categorical features

Categorical cell features can be 'attached' to the bubbletree using the function
`get_cat_tiles`. Here we will show the relative frequency of cell type labels 
across the bubbles (parameter `integrate_vertical=T`).

Interpretation of the figure below: 
  
  * we see high degree of co-occurrence between cell lines and bubbles, i.e. 
    each bubble is made up of cells from a distinct cell line
  * for instance, 99.8% of cells that have feature HCC827 are found in bubble 2
  * columns in the tile plot integrate to 100%

```{r, fig.width=7, fig.height=4, fig.align='center', echo=T}
w1 <- get_cat_tiles(btd = k5,
                    f = d@meta.data$cell_line_demuxlet,
                    integrate_vertical = T,
                    round_digits = 1,
                    show_hclust = F,
                    disable_hclust = F,
                    x_axis_name = 'Cell line',
                    rotate_x_axis_labels = T,
                    tile_text_size = 2.75)

(k5$tree|w1$plot)+
  patchwork::plot_layout(widths = c(1, 1))
```

We can also show the inter-bubble cell type composition, i.e. the relative 
frequencies of different cell types in a specific bubble (with parameter 
`integrate_vertical=F`).

Interpretation of the figure below: 
  
  * the bubbles appear to be "pure" $\rightarrow$ made up of cells from distinct 
    cell lines
  * the cell line composition of bubble 2 is: 0.1% H838, 99.9% H2228, 0.1% A549, 
    0.1% H1975 and 0% HCC827 cells
  * rows integrate to 100%

```{r, fig.width=7, fig.height=4, echo=T, fig.align='center'}
w2 <- get_cat_tiles(btd = k5,
                    f = d@meta.data$cell_line_demuxlet,
                    integrate_vertical = F,
                    round_digits = 1,
                    show_hclust = F,
                    disable_hclust = F,
                    x_axis_name = 'Cell line',
                    rotate_x_axis_labels = T,
                    tile_text_size = 2.75)

(k5$tree|w2$plot)+
  patchwork::plot_layout(widths = c(1, 1))
```

`scBubbletree` uses R-package `ggtree` to visualize the bubbletree, and 
`ggplot2` to visualize annotations. Furthermore, R-package `patchwork` is 
used to combine plots.

```{r, fig.width=9, fig.height=4, echo=T, fig.align='center'}
(k5$tree|w1$plot|w2$plot)+
  patchwork::plot_layout(widths = c(1, 2, 2))+
  patchwork::plot_annotation(tag_levels = "A")
```



### Gini impurity index

We can use Gini impurity with function `get_gini` to estimate the homogeneity 
of a set of labels $L$ (here cell lines) in each bubble $i$ with: 
$G_i=\sum_{j=1}^{L} \pi_{ij}(1-\pi_{ij})$
with $\pi_{ij}$ as the proportion of label $j$ in bubble $i$. In bubbles with 
homogeneous ('pure') composition of labels most $\pi$`s are close to either 1 
or 0, and the Gini index takes on a small value close to zero. In contrast to 
this, in bubbles with heterogenous ('impure') composition most $\pi$ are far 
from either 1 or 0, and the Gini index approaches its maximum value close to 1. 
To compute the total Gini impurity in a bubbletree we can compute the weighted 
Gini impurities across $k$ bubbles: 
$\overline{G}=\sum_{i=1}^{k} G_i \dfrac{n_i}{N}$,
with $n_i$ as the number of cells in cluster $i$ and $N$ the total number of 
cells in the sample. 

The Gini impurity results are shown below:

```{r, echo = T}
# gini
get_gini(labels = d@meta.data$cell_line_demuxlet, 
         clusters = k5$cluster)
```

All cluster-specific Gini impurity indices are close to 0 and thus also the 
weighted Gini impurity is close to 0. This indicates nearly perfect assignment
of cell line labels across the bubbles. This analysis can be done for different
$k$ values with function `get_gini_k`, which takes as main input the output of
`get_k`

```{r, echo = T}
gini_boot <- get_gini_k(labels = d@meta.data$cell_line_demuxlet,
                        get_k_obj = b)
```

From the figure we can conclude that the Gini impurity reaches values close to 
0 at `k=5`, and all labels are nearly perfectly split across the bubbles with 
each bubble containing cells exclusively from one cell type.

```{r, fig.width=4, fig.height=3, fig.align='center', echo=T}
g1 <- ggplot(data = gini_boot$total_gini_summary)+
  geom_point(aes(x = k, y = total_gini_mean), size = 0.75)+
  geom_errorbar(aes(x = k, y = total_gini_mean, ymin = L95, 
                    ymax = H95), width = 0.2)+
  ylab(label = "Gini impurity")+
  ylim(c(0, 1))

g1
```


```{r, echo=F, eval=F}
ggsave(filename = "manuscript_data/Gini_A.svg",
       plot = g1,
       device = "svg",
       width = 3,
       height = 3)
```



### attaching numeric features

We can also "attach" numeric cell features to the bubbletree. We will "attach" 
the expression of five marker genes, i.e. one marker gene for each of the five 
cancer cell lines. 

```{r, echo=T}
# First we need to select gene expressions for each cell and 
# also for five marker genes
as <- t(as.matrix(d@assays$SCT@data[
  rownames(d@assays$SCT@data) %in% 
    c("ALDH1A1", 
      "PIP4K2C", 
      "SLPI",
      "CT45A2",
      "CD74"), ]))

# 'as' is a matrix with n=rows for cells and a=columns for 
# annotations (genes). The column names will be shown in
# the plot.

# We will order the columns in 'as' in the same way we want
# them to be plotted. These genes are markers for: A549, 
# HCC827, H1975, H2228 and H838
as <- as[, c("ALDH1A1", 
             "PIP4K2C", 
             "SLPI",
             "CT45A2",
             "CD74")]

```


We can visualize numeric features in *two* ways.

First, we can show numeric feature aggregates (e.g. "mean", "median" or "sum")
in the different bubbles with `get_num_tiles`

```{r, fig.width=8, fig.height=4, fig.align='center', echo=T}
w3 <- get_num_tiles(btd = k5,
                    fs = as,
                    summary_function = "mean",
                    show_hclust = F,
                    disable_hclust = F,
                    x_axis_name = 'Gene expression',
                    rotate_x_axis_labels = T,
                    round_digits = 1,
                    tile_text_size = 2.75)

(k5$tree|w3$plot)+
  patchwork::plot_layout(widths = c(1, 1))
```


Second, we can visualize the distributions of the numeric cell features in each
bubble as violins with `get_num_violins`

```{r, fig.width=10, fig.height=4, fig.align='center', echo=T}
w4 <- get_num_violins(btd = k5,
                      fs = as,
                      x_axis_name = 'Gene expression',
                      rotate_x_axis_labels = T)

(k5$tree|w3$plot|w4$plot)+
  patchwork::plot_layout(widths = c(1.5, 2, 2.5))+
  patchwork::plot_annotation(tag_levels = 'A')
```

### quality control with `scBubbletree`
What is the percent of UMIs coming from mitochondrial genes in each bubble? 

```{r, fig.width=10, fig.height=4, fig.align='center', echo=T}
w_mt_dist <- get_num_violins(btd = k5,
                             fs = 1-d@meta.data$non_mt_percent,
                             x_axis_name = 'MT [%]',
                             rotate_x_axis_labels = T)

w_umi_dist <- get_num_violins(btd = k5,
                              fs = d@meta.data$nCount_RNA/1000,
                              x_axis_name = 'RNA count (in thousands)',
                              rotate_x_axis_labels = T)

w_gene_dist <- get_num_violins(btd = k5,
                               fs = d@meta.data$nFeature_RNA,
                               x_axis_name = 'Gene count',
                               rotate_x_axis_labels = T)


(k5$tree|w_mt_dist$plot|w_umi_dist$plot|w_gene_dist$plot)+
  patchwork::plot_layout(widths = c(1, 1, 1, 1))+
  patchwork::plot_annotation(tag_levels = 'A')
```





### Are H1975 and HCC827 transcriptionally similar?

To check this we will use gene expression data for 69 lung adenocarcinoma cell 
lines from the Cancer Cell Line Encyclopedia[^3]. Lets check if H1975 and 
HCC827 have similar gene expression profiles based on this data as well.

Procedure: a) compute the Euclidean distances all between pairs of cell line 
gene expressions; b) hierarchical clustering; c) are H1975 and HCC827 close 
to each other dendrogram?

```{r, fig.width=10, fig.height=4, fig.align='center', echo=T}
tpm <- read.csv(file = "manuscript_data/E-MTAB-2770-query-results.tpms.tsv", 
                sep = "\t", comment.char = "#")


tpm <- tpm[, c(1, 2, which(regexpr(pattern = "lung\\.adenocarcinoma", 
                                   text = colnames(tpm)) != -1))]
rownames(tpm) <- tpm$Gene.ID
tpm$Gene.ID <- NULL
tpm$Gene.Name <- NULL
tpm <- t(tpm)
rownames(tpm) <- gsub(pattern = "\\.\\.papillary\\.lung\\.adenocarcinoma|\\..lung\\.adenocarcinoma|NCI\\.", 
                      replacement = '', x = rownames(tpm))
rownames(tpm) <- gsub(pattern = "\\.",
     replacement = '',
     x = rownames(tpm))


h <- hclust(d = dist(tpm, method = "euclidean"), method = "average")

five_cell_lines <- c("H838", "H2228", "A549", "H1975", "HCC827")

cols <- rep(x = "black", times = length(h$labels))
cols[which(h$labels %in% five_cell_lines)] <- "red"

plot(as.dendrogram(h),
     label.offset = 1, nodePar = list(lab.cex = 0.7, cex = 0.7,
                                      pch = c(NA, 19)))
```


```{r, results='hide', echo=F, eval=F}
pdf(width = 8.5, height = 4.5,
    file = "manuscript_data/Fig_S1.pdf")
plot(as.dendrogram(h),
     label.offset = 1, nodePar = list(lab.cex = 0.7, cex = 0.7,
                                      pch = c(NA, 19)))
dev.off()
```




```{r, fig.width=6.5, fig.height=4}
get_sort_paste <- function(x) {
  return(paste0(sort(x), collapse = ' vs. '))
}

w <- as.matrix(dist(tpm, method = "euclidean"))
w <- melt(w)
colnames(w) <- c("c1", "c2", "d")
w$pair <- apply(X = w[, c("c1", "c2")], MARGIN = 1, FUN = get_sort_paste)
w <- w[w$c1 != w$c2, ]
w <- w[duplicated(w$pair)==F, ]
w <- w[order(w$d, decreasing = F), ]
w$rank <- 1:nrow(w)

q <- w[w$c1 %in% c("H838", "H2228", "A549", "H1975", "HCC827") & 
         w$c2 %in% c("H838", "H2228", "A549", "H1975", "HCC827"), ]


gdist <- ggplot()+
  geom_histogram(data = w, aes(d), bins = 50, fill = "gray", col = "gray")+
  geom_point(data = q, aes(x = d, y = 0), shape = 21, col = "red", size = 2,
             position = position_jitter(width = 0, height = 2))+
  geom_text_repel(data = q[q$pair == "H1975 vs. HCC827", ], 
                  aes(x = d, y = 0, label = pair), col = "red", size = 3,
                  min.segment.length = 0, max.overlaps = 100, nudge_y = 5,
                  force = 2, max.iter = 10^6)+
  theme_bw()+
  scale_x_log10()+
  annotation_logticks(base = 10, sides = "b")+
  xlab(label = "Euclidean distance")+
  ylab(label = "Frequency")

gdist
# ggsave(filename = "manuscript_data/Fig_S1.pdf",
#        plot = gdist,
#        device = "pdf",
#        width = 6.5,
#        height = 4)
```




## UMAP and t-SNE

Generating 2D UMAP and t-SNE plots is a standard first step in scRNA-seq data 
analysis. Lets do this now:

```{r, fig.width=8, fig.height=3.25, fig.align='center', echo = T}
umap_data <- cbind(d@meta.data, d@reductions$umap@cell.embeddings)
umap_data$closest_cluster <- NA
umap_centers <- merge(x = aggregate(UMAP_1~cell_line_demuxlet, 
                                    data = umap_data, FUN = median),
                      y = aggregate(UMAP_2~cell_line_demuxlet, 
                                    data = umap_data, FUN = median),
                      by = "cell_line_demuxlet")


tsne_data <- cbind(d@meta.data, d@reductions$tsne@cell.embeddings)
tsne_data$closest_cluster <- NA
tsne_centers <- merge(x = aggregate(tSNE_1~cell_line_demuxlet, 
                                    data = tsne_data, FUN = median),
                      y = aggregate(tSNE_2~cell_line_demuxlet, 
                                    data = tsne_data, FUN = median),
                      by = "cell_line_demuxlet")
```


```{r, fig.width=8, fig.height=3.25, fig.align='center', echo = T}
g_umap_tsne <- ggplot()+
  geom_point(data = umap_data,
             aes(x = UMAP_1, y = UMAP_2, col = cell_line_demuxlet), size = 0.25)+
  geom_text_repel(data = umap_centers,
            aes(x = UMAP_1, y = UMAP_2, label = cell_line_demuxlet), 
            min.segment.length = 0, size = 3)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))|
  ggplot()+
  geom_point(data = tsne_data,
             aes(x = tSNE_1, y = tSNE_2, col = cell_line_demuxlet), size = 0.25)+
  geom_text_repel(data = tsne_centers,
            aes(x = tSNE_1, y = tSNE_2, label = cell_line_demuxlet), 
            min.segment.length = 0, size = 3)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))

g_umap_tsne
```

The clustering of both algorithms seems to work well, i.e. cells from specific 
cell lines are clustered together. Two potential issues:

1. overplotting: points are stacked on top of each other $\rightarrow$ loss 
   of information about cell density distribution $\rightarrow$ we are
   unable to accurately answer two questions: 
      * which cell line contains most cells?
      * what are the relative frequencies of cells across cell lines?

2. preservation of long-range cell distances: UMAP and t-SNE focus on 
   preserving local cell distance (at the cost of global distances)
   $\rightarrow$ are there pairs of cell lines that are more similar to each
   other than the remaining ones in the sample?
 
These challenges will become more severe in real datasets (e.g. PBMC samples, 
see case study B) which contain many clusters of cells that are not clearly separable.



## Are local/global distances between cells preserved by UMAP/t-SNE?

Local cell distances appear to be adequatly recovered, long-range distances 
are not. Gray points are intra-bubble distances and black points are 
inter-bubble distances.

```{r, echo = T, results='hide'}

get_euc_dist <- function(x, pairs, m) {
  
  get_euc <- function(x, y) {
    return(sqrt(sum((x-y)^2)))
  }
  
  i <- pairs[x,1]
  j <- pairs[x,2]

  return(sqrt(sum((m[i,]-m[j,])^2))) 
}


pairs <- t(replicate(n = 5*10^4, sample(x = 1:nrow(A), size = 2)))

i_cell <- d@meta.data$cell_line_demuxlet[pairs[, 1]]
j_cell <- d@meta.data$cell_line_demuxlet[pairs[, 2]]
comparison <- ifelse(test = i_cell==j_cell, yes = "w", no = "b")

```


```{r, echo = T, results='hide'}

euc_a <- lapply(X = 1:nrow(pairs), pairs = pairs, 
                m = A, FUN = get_euc_dist)

euc_u <- lapply(X = 1:nrow(pairs), pairs = pairs, 
                m = umap_data[, c("UMAP_1", "UMAP_2")], FUN = get_euc_dist)

euc_t <- lapply(X = 1:nrow(pairs), pairs = pairs, 
                m = tsne_data[, c("tSNE_1", "tSNE_2")], FUN = get_euc_dist)

euc_x <- lapply(X = 1:nrow(pairs), pairs = pairs, 
                m = t(as.matrix(d@assays$SCT@data)), FUN = get_euc_dist)


dist_preservation <- data.frame(euc_a = unlist(euc_a), 
                                euc_u = unlist(euc_u), 
                                euc_t = unlist(euc_t), 
                                euc_x = unlist(euc_x),
                                i = i_cell, 
                                j = j_cell, 
                                comparison = comparison)
```






```{r, fig.width=8, fig.height=4, fig.align='center', echo = T}
g_pairs_umap_tsne <- ggplot(data = dist_preservation)+
  geom_point(aes(y = euc_a, x = euc_u, col = comparison), size = 0.25)+
  geom_density_2d(aes(y = euc_a, x = euc_u), col = "orange")+
  ylab(label = "Distance [PCA]")+
  xlab(label = "Distance [2D UMAP]")+
  scale_color_manual(values = c("black", "darkgray"))+
  theme(legend.position = "none")|
ggplot(data = dist_preservation)+
  geom_point(aes(y = euc_a, x = euc_t, col = comparison), size = 0.25)+
  geom_density_2d(aes(y = euc_a, x = euc_t), col = "orange")+
  ylab(label = "Distance [PCA]")+
  xlab(label = "Distance [2D t-SNE]")+
  scale_color_manual(values = c("black", "darkgray"))+
  theme(legend.position = "none")

g_pairs_umap_tsne
```





### scBubbletree can incorporate results from other clustering approaches

Wide range of clustering approaches are used for clustering of scRNA-seq data. 
`scBubbletree` implements the function `get_dummy_bubbletree` to allow users
to incorporate results from various clustering approaches together with our 
workflow. With this function we skip the k-means clustering portion of the 
workflow and proceed with computing distances between the clusters and 
generation of the bubbletree.

Lets try `get_dummy_bubbletree`. First, will perform k-medoids clustering with
R-package pam and then generate the bubbletree:

```{r, fig.width=7, fig.height=4, fig.align='center', echo=T}
pam_k5 <- cluster::pam(x = A, k = 5, metric = "euclidean")

dummy_k5_pam <- get_dummy_bubbletree(x = A,
                                     cs = pam_k5$clustering,
                                     B = 200,
                                     N_eff = 100,
                                     cores = 2,
                                     round_digits = 1)

dummy_k5_pam$tree|
  get_cat_tiles(btd = dummy_k5_pam, 
                f = d@meta.data$cell_line_demuxlet,
                integrate_vertical = T,
                round_digits = 1,
                show_hclust = F,
                disable_hclust = F,
                tile_text_size = 2.75,
                x_axis_name = 'Cell line',
                rotate_x_axis_labels = T)$plot
```

We can also use graph-based approaches for clustering. We will identify 
clusters of cells by a shared nearest neighbor (SNN) modularity optimization 
based clustering algorithm. First calculate k-nearest neighbors and construct 
the SNN graph.

```{r, fig.width=7, fig.height=6, fig.align='center', echo=T}
d_clust <- Seurat::FindNeighbors(d, 
                                 reduction = "pca",
                                 dims = 1:15)
d_clust <- Seurat::FindClusters(d_clust, 
                                resolution = 1)


dummy_k5_snn <- get_dummy_bubbletree(x = A,
                                     cs = as.vector(d_clust@meta.data$seurat_clusters),
                                     B = 200,
                                     N_eff = 100,
                                     cores = 2,
                                     round_digits = 1)



dummy_k5_snn$tree|
  get_cat_tiles(btd = dummy_k5_snn, 
                f = d@meta.data$cell_line_demuxlet,
                integrate_vertical = T,
                round_digits = 1,
                show_hclust = F,
                disable_hclust = F,
                tile_text_size = 2.75,
                x_axis_name = 'Cell line',
                rotate_x_axis_labels = T)$plot
```



<!-- ## In-depth inspection of sets of bubbles -->
<!-- Imagine a branch of bubbles (or even a single bubble) in the bubbletree that  -->
<!-- is of particular interest to us. We might want to have a more in-depth look  -->
<!-- into the substructre structure of that bubble. `scBubbletree` provides the -->
<!-- function `update_bubbletree` which allows you to perform additional clustering -->
<!-- over specific set of bubbles and to update the original bubbletree. -->

<!-- Let's say we want to look deeper into bubbles 1, 2 and 3, which correspond to  -->
<!-- cell lines H1975, HCC827 and A549, respectively. We would like to double the -->
<!-- clustering resolution, i.e. from 3 bubbles in the original bubbletree now we  -->
<!-- want to obtain 6 bubbles. The function will update the bubbles and the -->
<!-- dendrogram structure.  -->

<!-- *Caveat:* this function was implemented to help the user gain better  -->
<!-- understanding of the data. It is important to note that the final clustering -->
<!-- solution obtained with this function is not necessarily the optimal clustering  -->
<!-- solution, i.e. clustering with global minimum within cluster sum of squares. -->

<!-- ```{r} -->
<!-- u_k5 <- update_bubbletree(btd = k5, -->
<!--                           updated_bubbles = c("1", "2", "3"), -->
<!--                           k = 6, -->
<!--                           cores = 20) -->
<!-- ``` -->

<!-- Notice the new 6 bubbles with names 1_A to 1_F. The prefix 1 stands for the  -->
<!-- updating iteration, i.e. if we performed an additional updating of u_k5, then -->
<!-- the new bubble names would start with prefix 2. -->

<!-- Bubble 1 from the original bubbletree was not subdivided into additional bubbles  -->
<!-- and has the name 1_E. Bubble 2, on the othr hand is now split into bubbles  -->
<!-- 1_A and 1_B. Bubble 3 is split into 3 bubbles: 1_C, 1_D, 1_F. -->

<!-- We should further inspect each of the new bubbles to try and understand whether -->
<!-- they carry some distinguishing biological features. As case study A deals with -->
<!-- a toy dataset this updating analysis is not necessary, however, when analyzing -->
<!-- more complex datasets (e.g. see case study B) having the ability to zoom into -->
<!-- clades or bubbles can be extremely beneficial and revealing. -->

<!-- ```{r, fig.width=7, fig.height=4, fig.align='center', echo=T} -->
<!-- u_w1 <- get_cat_tiles(btd = u_k5, -->
<!--                       f = d@meta.data$cell_line_demuxlet, -->
<!--                       integrate_vertical = T, -->
<!--                       round_digits = 1, -->
<!--                       show_hclust = F, -->
<!--                       disable_hclust = F, -->
<!--                       tile_text_size = 2.75, -->
<!--                       x_axis_name = 'Cell line', -->
<!--                       rotate_x_axis_labels = T)$plot -->

<!-- (u_k5$tree|u_w1)+ -->
<!--   patchwork::plot_layout(ncol = 2, widths = c(1, 1)) -->
<!-- ``` -->





### Summary

`scBubbletree` promotes simple and transparent analysis of scRNA-seq. It is 
*not a black-box* approach and the user *is encouraged* to explore the data 
with different values of $k$. At each stage the user should 'attach' annotation 
to the bubbletree for better biological interpretation of the different bubbles 
and their relationships which are described by the bubbletree topology.






<!-- ### What if we selected $k=6$ -->

<!-- ```{r} -->
<!-- k6 <- get_bubbletree(x = A, -->
<!--                      k = 6, -->
<!--                      seed = 1234, -->
<!--                      cores = 1, -->
<!--                      B = 200, -->
<!--                      N_eff = 200, -->
<!--                      round_digits = 1, -->
<!--                      show_simple_count = F, -->
<!--                      kmeans_algorithm = "MacQueen") -->


<!-- save(k6, file = "case_study_A/k6.RData") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- w1 <- get_cat_tiles(btd = k6, -->
<!--                     f = d@meta.data$cell_line_demuxlet, -->
<!--                     integrate_vertical = T, -->
<!--                     round_digits = 1, -->
<!--                     show_hclust = F, -->
<!--                     disable_hclust = F, -->
<!--                     x_axis_name = 'Cell line', -->
<!--                     rotate_x_axis_labels = T, -->
<!--                     tile_text_size = 2.75) -->

<!-- (k6$tree|w1$plot)+ -->
<!--   patchwork::plot_layout(widths = c(1, 1)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- umap_data$bubble_k6 <- k6$cluster -->

<!-- umap_centers <- merge(x = aggregate(UMAP_1~bubble_k6,  -->
<!--                                     data = umap_data, FUN = median), -->
<!--                       y = aggregate(UMAP_2~bubble_k6,  -->
<!--                                     data = umap_data, FUN = median), -->
<!--                       by = "bubble_k6") -->
<!-- ``` -->



<!-- ```{r} -->
<!-- ggplot()+ -->
<!--   geom_point(data = umap_data, -->
<!--              aes(x = UMAP_1, y = UMAP_2, col = as.factor(bubble_k6)), size = 0.25)+ -->
<!--   geom_text_repel(data = umap_centers, -->
<!--             aes(x = UMAP_1, y = UMAP_2, label = bubble_k6),  -->
<!--             min.segment.length = 0, size = 3)+ -->
<!--   theme_bw(base_size = 10)+ -->
<!--   theme(legend.position = "none")+ -->
<!--   guides(colour = guide_legend(nrow = 4, -->
<!--                                override.aes = list(size=2))) -->
<!-- ``` -->



```{r, echo=F}
# save image
save.image(file = "case_study_A/workspace_image.RData")
```









```{r, echo=F}
# variable cleanup
rm(b, k5, d, meta, w1, w2, w3, w4, A, as, u, gini_boot,
   g, g0, g1, h, tpm, x, cell_line_pattern, cols)
```



[^1]: Tian, Luyi, et al. "Benchmarking single cell RNA-sequencing analysis 
pipelines using mixture control experiments." Nature methods 16.6 (2019): 
479-487.
[^2]: https://github.com/LuyiTian/sc_mixology/blob/master/data/sincell_with_class_5cl.RData
[^3]: https://www.ebi.ac.uk/gxa/experiments/E-MTAB-2770/Results
