---
title: "Case study B: Exploring massive CITE-seq data from 161k PBMCs with scBubbletree"
author: "SK"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---


```{r, echo=F}
source(file = "~/Rutil/Init_Rpack.R")
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = F, 
                      comment = F, 
                      warning = F, 
                      message = F)
```


This vignette introduces `scBubbletree`, a transparent workflow for exploration
of single cell RNA-seq data. To run this vignette we need a few R-packages:


```{r, echo = T, eval = F, results='hide'}
library(scBubbletree)
library(Seurat)
library(ggrepel)
library(SeuratDisk)
```


```{r, echo = F, results='hide'}
library(scBubbletree)
library(Seurat, lib.loc = lib.loc)
library(ggrepel, lib.loc = lib.loc)
library(SeuratDisk, lib.loc = lib.loc)
```


```{r, echo=F}
redo_case_b <- F
```



## Data

In this case study we will analyze a scRNA-seq dataset of 161,764 cells 
peripheral blood mononuclear cells (PBMCs) from eight healthy volunteers 
enrolled in an HIV vaccine trial[^1]. Analysis of this data based on Seurat
is presented here[^2]

Sample collection and data processing details are provided in the respective 
publication. In the following we summarize the key workflow steps. Key data 
collection and processing steps are summarized in the following. Samples were 
collected at three time points: immediately before (day 0), 3 days, and 7 days 
following administration of a HIV vaccine. All samples were profiled using 
10x Chromium 3' protocol, followed by Illumina NovaSeq 6000 sequencing. 
Alongside the single cell transcriptomes, CITE-seq technology was used with up 
to 228 antibodies to profile cell-surface protein expression. 

This multimodal data was processed with a weighted nearest neighbor (WNN) 
procedure to identify different cellular states in PBMCs. Cell types were 
predicted by this approach for each cell at three levels of resolution: l1 
with 8 cell types and l2 with 31 cell types. The predictions are available 
as part of the meta data associated with the raw scRNA-seq data.

```{r, echo=T, eval=F}
# create directory
dir.create(path = "case_study_B/")


# 1. download reference data from vignette:
https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat


# 2. load SeuratDisk
d <- LoadH5Seurat("case_study_B/pbmc_multimodal.h5seurat")
save(d, file = "case_study_B/Hao_2021.RData")


# 3. remove precomputed reductions
d <- get(load(file = "case_study_B/Hao_2021.RData"))
d[["mt"]] <- PercentageFeatureSet(d, pattern = "^MT-")
d@reductions$apca <- NULL
d@reductions$aumap <- NULL
d@reductions$spca <- NULL
d@reductions$wnn.umap <- NULL
d@reductions$umap <- NULL


# 4. run UMAP and t-SNE again
d <- RunUMAP(object = d, dims = 1:15, reduction = "pca")
d <- RunTSNE(object = d, dims = 1:15, reduction = "pca")
save(d, file = "case_study_B/Hao_2021.RData")
```


```{r}
d <- get(load(file = "case_study_B/Hao_2021.RData"))
```



Lets look at the number of cells per donor at a given sampling time:

```{r, echo = T}
table(d@meta.data$time, d@meta.data$donor)
```


We can show the number of cells per donor and predicted cell type from
annotation set *l1*

```{r, echo=T}
table(d@meta.data$celltype.l1, d@meta.data$donor)
```


... and also from annotation set *l2*

```{r, echo=T}
table(d@meta.data$celltype.l2, d@meta.data$donor)
```


How many distinct *cell types* are there in each annotation set?

```{r, echo=T}
length(unique(d@meta.data$celltype.l1))
length(unique(d@meta.data$celltype.l2))
```



## scBubbletree
   
We will analyze this data with `scBubbletree`. 

As first input `scBubbletree` uses matrix $A^{n\times f}$ which represents a 
low-dimensional projection of the original scRNA-seq data, with $n$ rows as 
cells and $f$ columns as low-dimension features. 

We will use the PCA data generated by `Seurat` as $A$. In particular, we will 
use the first 15 principal components (PCs) as every additional PC explains 
negligible amount of variance in the data.

```{r, fig.width=4, fig.height=3, echo=T, fig.align='center'}
var_explained <- ((d[["pca"]]@stdev)^2)/d[["pca"]]@misc$total.variance

g_var_explained <- ggplot(data = data.frame(var_explained = var_explained*100,
                                            PC = 1:length(var_explained)))+
  geom_point(aes(y = var_explained, x = PC), size = 1)+
  ylab(label = "Variance explained [%]")

g_var_explained
```

```{r, echo = T}
# This is the main input of scBubbletree -> matrix A
A <- d@reductions$pca@cell.embeddings[, 1:15]

# A has n=cells as rows, f=features as columns (e.g. from PCA)
dim(A)
```



```{r, echo = T}
# meta data
meta <- d@meta.data
```


```{r, echo = T}
# quantitative features (gene expressions of marker genes) to be used later on:
# * GNLY, NKG7:	NK cells
# * IL7R:	CD4 T cells
# * CD8A:	CD8 T cells
# * MS4A1:	B cells
# * CD14, LYZ:	CD14+ Monocytes
# * FCGR3A, MS4A7:	FCGR3A+ Monocytes
# * FCER1A, CST3:	Dendritic Cells
# * PPBP:	Megakaryocytes
as <- t(as.matrix(d@assays$SCT@data[
  rownames(d@assays$SCT@data) %in% 
    c("IL7R", 
      "CD14", "LYZ", 
      "MS4A1", 
      "CD8A", 
      "GNLY", "NKG7",
      "FCGR3A", "MS4A7",
      "FCER1A", "CST3",
      "PPBP"), ]))
```



The `scBubbletree` workflow performs the following steps:
  
  1. determine number of clusters $k$
  2. $k$-means clustering
  3. hierarchical organization of clusters (bubbles)
  4. annotation and evaluation


### 1. determining the number of clusters $k$
How many clusters (cell types) are there are in the data? C we guess a 
reasonable value of $k$? 

Two approaches should be used to find $k$. 

First, we need to study the literature or databases such as the human protein 
atlas database (HPA) to identify a reasonable range of $k$s. HPA provides a 
decomposition of PBMCs into 18 canonical cell populations[^3]. Given that here
we have about 162k PBMCs we might be able to recover all 18 subtypes, and hence
$k\approx18$ is a reasonable first choice.

Second, we can use the function `get_k` for data-driven inference of $k$ based 
on the Gap statistic and the within-cluster sum of squares (WCSS).
  
Lets run `get_k` now. We will use the function `get_k` for this. Notice the 
modified parameter `cv_prop=0.15` (15% of the rows (cells) in A will be used), 
for faster execution of this large dataset.

```{r, fig.width=4, fig.height=3, echo = T, eval=F}
b <- get_k(B = 10,
           cv_prop = 0.15, # use 15% for gap stat.
           ks = seq(from = 1, to = 40, by = 1),
           x = A,
           n_start = 100,
           iter_max = 200,
           kmeans_algorithm = "MacQueen",
           cores = 20,
           mini_output = F,
           B_gap = 5)
```


```{r, fig.width=4, fig.height=3, echo = T, eval = T}
if(redo_case_b) {
  b <- get_k(B = 10,
             cv_prop = 0.15, # use 15% for gap stat.
             ks = seq(from = 1, to = 40, by = 1),
             x = A,
             n_start = 100,
             iter_max = 200,
             kmeans_algorithm = "MacQueen",
             cores = 20,
             mini_output = F,
             B_gap = 5)
  
  if(dir.exists("case_study_B")==F) {
    dir.create("case_study_B")
  }
  save(b, file = "case_study_B/b.RData")
  cat("Done.")
} else {
  b <- get(load("~/scBubbletree/case_study_B/b.RData"))
}

```


The Gap statistic curve and the WCSS curve appeared to follow three general 
regimes. In the first regime we saw a steep increase in the Gap statistic and 
a steep decrease in WCSS for values of $k$ between 1 and 4 (approximately the 
number of major PBMC subtypes). Second, between $k\approx4$ and $k\approx18$ 
both curves followed similar trends as before but had smaller slopes, i.e. 
the change in the Gap statistic and WCSS as a function of $k$ was smaller 
in the second regime. Third, both curves leveled off around $k\approx18$, 
and incremental increase in $k$ beyond this point resulted in negligible 
changes in either metric. 

In summary, the Gap statistic and WCSS curves were consistent with our prior 
knowledge about PBMCs, i.e. at $k\approx18$ most of the canonical PBMC cell 
populations are likely to have been recovered by the clustering, and there is 
little benefit in using larger values of $k$. Importantly, the final choice of 
$k$ also depends on the intent of the researcher and on the design of the 
experiment. Given that dataset B was generated at high throughput and consists 
of over 161,000 cells, we decided to use $k=20$ for the clustering step as 
this would enable us to recover most of the canonical PBMC subtypes.


```{r}
g0 <- ggplot(data = b$gap_stats_summary)+
  geom_point(aes(x = k, y = gap_mean), size = 1)+
  geom_errorbar(aes(x = k, y = gap_mean, ymin = L95, ymax = H95), width = 0.1)+
  ylab(label = "Gap")|
ggplot(data = b$wcss_stats_summary)+
  geom_point(aes(x = k, y = wcss_mean), size = 1)+
  geom_errorbar(aes(x = k, y = wcss_mean, ymin = L95, ymax = H95), width = 0.1)+
  ylab(label = "WCSS")+
  scale_y_log10()+
  annotation_logticks(base = 10, sides = "l")
```


```{r, fig.width=7, fig.height=3, fig.align='center'}
g0
```


### 2. $k$-means clustering
We will perform clustering with $k=20$ and $A$ as inputs. We use 
the function kmeans (R-package stats) which offers various k-means 
variants. Here we will use MacQueen's k-means variant, which will 
perform $n_{start} = 1000$ (default in scBubbletree) random starts 
and a maximum number of iterations $iter_{max} = 300$. 

### 3. hierarchical grouping
After the clustering is complete we will organize the bubbles in a natural
hierarchy. We will use $B=200$ bootstrap iterations. In iteration $b$ the 
algorithm will draw $N_{eff}=200$ cells with replacement from each cluster 
and compute the average inter-cluster Euclidean distances. This data is used 
to populate the distance matrix ($D^{k\times k}_b$), which is provided as 
input for hierarchical clustering with average linkage to generate a 
hierarchical clustering dendrogram $H_b$. 

The collection of distance matrices that are computed during $B$ 
iterations are used to compute a consensus (average) distance matrix 
($\hat{D}^{k\times k}$) and a corresponding consensus hierarchical 
dendrogram (bubbletree; $\hat{H}$). The collection of dendrograms 
are used to quantify the robustness of the bubbletree topology, i.e.
to count the number of times each branch in the bubbletree is found 
among the topologies of the bootstrap dendrograms. Branches can have 
has variable degrees of support ranging between 0 (no support) and $B$ 
(complete support). Distances between bubbles (inter-bubble relationships) 
are described quantitatively in the bubbletree as sums of branch lengths. 

Steps 2. and 3. are performed next

```{r, echo=T, eval=F}
k20 <- get_bubbletree(x = A,
                      k = 20,
                      seed = 4321,
                      n_start = 1000,
                      iter_max = 1000,
                      cores = 20,
                      B = 200,
                      N_eff = 200,
                      round_digits = 1,
                      show_simple_count = T)
```


```{r, echo=T}

if(redo_case_b) {
  k20 <- get_bubbletree(x = A,
                        k = 20,
                        seed = 4321,
                        n_start = 1000,
                        iter_max = 1000,
                        cores = 20,
                        B = 200,
                        N_eff = 200,
                        round_digits = 1,
                        show_simple_count = T)
  save(k20, file = "case_study_B/k20.RData")
} else {
  k20 <- get(load("~/scBubbletree/case_study_B/k20.RData"))
}

```


... and plot the bubbletree

```{r, fig.width=4, fig.height=6, fig.align='center', echo=T}
k20$tree
```

Lets describe the bubbletree:

**bubbles**: The bubbletree has `k=20` bubbles (clusters) shown as leaves. 
The absolute and relative cell frequencies in each bubble and the bubble 
IDs are shown as labels. Bubble radii and color-code represent cell count 
in each bubble, i.e. large & dark bubbles have many cells and small & light 
bubbles contain few cells. 

Bubble 14 is remarkably large and dark as it contains about 33,100 (19.2% of 
the cells in the dataset). In contrast to this, bubbles 9, 13, 5 and 17 are 
small and white as they contained between 600 (0.4%) and 1,300 (0.8%) cells. 
The remaining bubbles contained between 2,700 (1.7%) and 15,900 (9.8%) cells, 
and had small to medium sizes and varying levels of brightness.

We can access the bubble data shown in the bubbletree

```{r, echo=T, results=T}
knitr::kable(k20$tree_meta, digits = 2, row.names = F)
```


**topology**: inter-bubble distances are represented by sums of the 
corresponding branch lengths in the dendrogram. 

The topology of the bubbletree contained two major clades. The top clade 
consists of ten bubbles (19, 11, 14, 8, 6, 16, 3, 4, 15, 10), which 
collectively account for about 65% of the cells in the sample. The bottom 
clade contained six bubbles (18, 12, 20, 1, 2, 7), which contained about 32% 
of the sample cells. Judged alone from the relative frequencies of the cells
in each clade, we predicted that the top clade is enriched with lymphocytes 
(the most dominant PBMC subtype) and the bottom clade by monocytes. The 
remaining bubbles 17, 5, 13 and 9 were shown as an outgroup and accounted 
for less than 3% of the cells in the dataset. All branches of the bubbletree 
are robust, except for the branch joining bubble 19 and 11, which is found 
in 170 (85%) out of 200 bootstrap dendrograms. 

Biological interpretation of the different clades and their complex within-
clade branching patterns are provided in the following.

### 4. annotation and evaluation


#### attaching categorical cell features
We will visualize the relative frequencies of categorical cell features 
including: 
  
  * cell type annotations *l1* and *l2*
  * donor (sample) IDs
  
```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
c1 <- meta$celltype.l1
c2 <- gsub(pattern = "Proliferating", replacement = 'prolif.', meta$celltype.l2)
c2 <- gsub(pattern = "CD56bright", replacement = 'CD56', x = c2)
donor <- paste0(meta$donor, '(', meta$time, ')')
```


```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
w0_v <- get_cat_tiles(btd = k20,
                    f = c1,
                    integrate_vertical = T,
                    round_digits = 0,
                    show_hclust = F,
                    tile_text_size = 2.75,
                    disable_hclust = F,
                    x_axis_name = 'Cell type (l1)')


w0_h <- get_cat_tiles(btd = k20,
                    f = c1,
                    integrate_vertical = F,
                    round_digits = 0,
                    show_hclust = F,
                    tile_text_size = 2.75,
                    disable_hclust = F,
                    x_axis_name = 'Cell type (l1)')
```


```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
w1_v <- get_cat_tiles(btd = k20,
                    f = c2,
                    integrate_vertical = T,
                    round_digits = 0,
                    show_hclust = F,
                    tile_text_size = 2.75,
                    disable_hclust = F,
                    x_axis_name = 'Cell type (l2)')

w1_h <- get_cat_tiles(btd = k20,
                    f = c2,
                    integrate_vertical = F,
                    round_digits = 0,
                    show_hclust = F,
                    tile_text_size = 2.75,
                    disable_hclust = F,
                    x_axis_name = 'Cell type (l2)')
```


```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
w2 <- get_cat_tiles(btd = k20,
                    f = donor,
                    integrate_vertical = T,
                    round_digits = 0,
                    show_hclust = F,
                    tile_text_size = 2.75,
                    disable_hclust = T,
                    x_axis_name = 'Donor')
```




```{r, echo=T, results='hide'}
fig_l0 <- g0

fig_l1 <- (k20$tree|w0_v$plot|w0_h$plot)+
  patchwork::plot_layout(widths = c(2, 3, 3))

fig_l2 <- (k20$tree|w1_v$plot|w1_h$plot)+
  patchwork::plot_layout(widths = c(2, 3, 3))

fig <- (fig_l0/fig_l1/fig_l2)+
  patchwork::plot_annotation(tag_levels = 'A')+
  patchwork::plot_layout(heights = c(1, 2, 2))

rm(fig_l0, fig_l1, fig_l2)
```



```{r, fig.width=14, fig.height=12}
fig
```


#### attaching numeric cell features

Lets visualize the average gene expression of 
some marker genes in the bubbles:

  * GNLY, NKG7:	*NK cells*
  * IL7R:	*CD4 T cells*
  * CD8A:	*CD8 T cells*
  * MS4A1:	*B cells*
  * CD14, LYZ:	*CD14+ Monocytes*
  * FCGR3A, MS4A7:	*FCGR3A+ Monocytes*
  * FCER1A, CST3:	*Dendritic Cells*
  * PPBP:	*Megakaryocytes*

```{r, fig.width=8, fig.height=8, fig.align='center', echo=T}
fig_markers <- get_num_tiles(btd = k20,
                             fs = as,
                             summary_function = "mean",
                             round_digits = 1,
                             show_hclust = F,
                             disable_hclust = T,
                             x_axis_name = "Gene expression",
                             rotate_x_axis_labels = T)

(k20$tree|fig_markers$plot)+
  patchwork::plot_layout(widths = c(1, 1))
```

Second, we can visualize the distribution of each marker gene in each 
bubble using violin plots with `get_num_violins`. This function uses 
the same input as `get_num_tiles`. 

Lets invoke this function now.

```{r, fig.width=8, fig.height=10, fig.align='center', echo=T}
fig_markers_violin <- get_num_violins(btd = k20,
                      fs = as,
                      x_axis_name = "Gene expression",
                      rotate_x_axis_labels = T)


((k20$tree|fig_markers$plot)+
    patchwork::plot_layout(widths = c(1, 1)))/
  fig_markers_violin$plot
```



### quality control with `scBubbletree`

```{r, echo = F, fig.align='center', fig.width=5, fig.height=4.5}
sup_w <- (get_num_violins(btd = k20,
                          fs = meta$mt*100,
                          x_axis_name = "MT [%]",
                          rotate_x_axis_labels = F)$plot|
            get_num_violins(btd = k20,
                            fs = meta$nCount_RNA/1000,
                            x_axis_name = "RNA count (in thousands)",
                            rotate_x_axis_labels = F)$plot|
            get_num_violins(btd = k20,
                            fs = meta$nFeature_RNA,
                            x_axis_name = "Gene count",
                            rotate_x_axis_labels = F)$plot
)

sup_w
```

Interestingly, the bubbles 1 and 2 contain many different cell types. 
Additional clustering of these bubbles might be necessary.



### bubble purity assessment based on Gini impurity index
Can we show quantitatively that by increasing `k` we get "better" 
clustering in a semi-supervised way? Yes, we can use the Gini impurity 
index.

For this we will integrate the results obtained by function `get_k` 
with *l1*, *l2* and *l3* cell type predictions (labels), and show 
quantitatively the change in Gini index as a function of `k`. This 
is done with the function `get_gini_k`. One potential caveat of this 
approach is that some of the predictions might be inaccurate. 

Lets invoke the function `get_gini_k` and pass the object `b` obtained 
earlier together with the cell type predictions:

```{r, echo = T}
b <- get(load("~/scBubbletree/case_study_B/b.RData"))
gini_l1 <- get_gini_k(labels = meta$celltype.l1,
                      get_k_obj = b)
gini_l2 <- get_gini_k(labels = meta$celltype.l2,
                      get_k_obj = b)
gini_l3 <- get_gini_k(labels = meta$celltype.l3,
                      get_k_obj = b)
```


We next plot the Gini scores for the labels at resolution *l1*, *l2* and *l3*.

Summary of the plot:
More abstract cell types can be segmented more accurately and the resulting 
segmentation has lower total Gini impurity. In each curve the total Gini 
impurity appears to decrease slowly for as $k$ approaches 20. This indicates 
that our previous data-based indices provide meaningful results.

```{r, fig.width=5, fig.height=4, fig.align='center'}
l1 <- gini_l1$total_gini_summary
l1$level <- "l1"

l2 <- gini_l2$total_gini_summary
l2$level <- "l2"

l3 <- gini_l3$total_gini_summary
l3$level <- "l3"

l_summary <- rbind(l1, l2, l3)

g_gini <- ggplot(data = l_summary)+
  geom_point(aes(x = k, y = total_gini_mean, 
                 col = level, shape = level), 
             size = 1)+
  geom_errorbar(aes(x = k, y = total_gini_mean, ymin = L95, 
                    ymax = H95, col = level), width = 0.1)+
  scale_color_manual(name = "R",
                     values = c("black", "#787777", "gray"))+
  scale_shape_manual(name = "R", values = c(1, 2, 3))+
  theme(legend.position = "top")+
  ylab(label = "Gini impurity")+
  ylim(c(0,1))+
  xlab(label = "k-means clusters (k)")

g_gini
```





# References

[^1]: Hao, Yuhan, et al. "Integrated analysis of multimodal single-cell 
data." Cell 184.13 (2021): 3573-3587.
[^2]: https://satijalab.org/seurat/articles/multimodal_reference_mapping.html
[^3]: https://www.proteinatlas.org/humanproteome/immune+cell
