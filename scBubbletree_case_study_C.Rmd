---
title: "Case study C: Exploring digit recognition data with scBubbletree"
author: "SK"
output: 
  rmarkdown::html_document:
    toc: true
    toc_depth: 1
vignette: >
  %\VignetteIndexEntry{}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r setup, include = FALSE}
source(file = "~/Rutil/Init_Rpack.R")
knitr::opts_chunk$set(echo = F,
                      comment = F, 
                      warning = F, 
                      message = F)
```


In this vignette we will use `scBubbletree` to perform clustering of images
containing digits. 

```{r, echo = T, results='hide'}
source(file = "../Rutil/Graphics.R")

source(file = "../scBubbletree/R/util.R")
source(file = "../scBubbletree/R/main.R")
source(file = "../scBubbletree/R/annotation.R")
```


```{r, echo = T, results='hide'}
library(cluster, lib.loc = lib.loc)
library(Seurat, lib.loc = lib.loc)
library(ggplot2, lib.loc = lib.loc)
library(reshape2, lib.loc = lib.loc)
library(parallel, lib.loc = lib.loc)
library(ape, lib.loc = lib.loc)
library(ggtree, lib.loc = lib.loc)
library(org.Hs.eg.db, lib.loc = lib.loc)
library(bluster, lib.loc = lib.loc)
library(SummarizedExperiment, lib.loc = lib.loc)
library(ggrepel, lib.loc = lib.loc)
library(Rtsne, lib.loc = lib.loc)
```


```{r}
redo_case_c <- F
```





# Case study C: digit recognittion

```{r}
# Note: This example is adapted from an the example in the book Python 
# Datascience handbook by Jake VanderPlas https://jakevdp.github.io/PythonDataScienceHandbook/05.09-principal-component-analysis.html)


# Read the digits data
digits <- read.csv("raw_data/Digits/digits.csv")

# ground truth
digit_classes <- digits$X0.000000000000000000e.00.29

```

```{r}
x <- digits

qs <- c()
for(i in 1:nrow(digits)) {
  m <- matrix(data = as.numeric(digits[i, 1:64]), byrow = T, ncol = 8)
  q <- melt(m)
  colnames(q) <- c("y", "x", "v")
  q$i <- i
  q$class <- digit_classes[i]
  qs <- rbind(qs, q)
}
rm(m, q, i, x)
```


```{r, fig.width=3, fig.height=3, fig.align='center', echo=T}
tmp_qs <- c()
for(i in 1:9) {
  tmp <- qs[qs$i %in% qs$i[which(qs$class == i)[100]], ]
  tmp_qs <- rbind(tmp_qs, tmp)
}
rm(i, tmp)
g_digits <- ggplot(data = tmp_qs)+
  facet_wrap(facets = ~paste0(class), nrow = 4)+
    geom_tile(aes(x = x, y = y, fill = v))+
  theme_bw(base_size = 10)+
  theme(legend.position = "none",
        strip.text.x = element_text(margin = margin(0.015,0,0.015,0, "cm")))+
  scale_fill_gradient(low = "white", high = "black")+
  scale_x_continuous(name = "x pixel", expand = c(0, 0))+
  scale_y_continuous(name = "y pixel", expand = c(0, 0))
g_digits
```


```{r, fig.width=4, fig.height=3, fig.align='center', echo=T}
# PCA 
PCA = stats::prcomp(digits[,1:64])

# get variance explained by PCs
summary_PCA <- rbind(
  SD = sqrt(PCA$sdev^2),
  Proportion = PCA$sdev^2/sum(PCA$sdev^2),
  Cumulative = cumsum(PCA$sdev^2)/sum(PCA$sdev^2))

plot(summary_PCA["Proportion",]*100, ylab = "Var explained [%]")
```



```{r}
umap <- umap::umap(d = digits[,1:64])
```



```{r, fig.width=5, fig.height=3.25, fig.align='center', echo = T}
umap_data <- data.frame(UMAP_1 = umap$layout[, 1],
                        UMAP_2 = umap$layout[, 2],
                        digit = digit_classes)
umap_centers <- merge(x = aggregate(UMAP_1~digit, data = umap_data, FUN = median),
                      y = aggregate(UMAP_2~digit, data = umap_data, FUN = median),
                      by = "digit")

g_umap <- ggplot()+
  geom_point(data = umap_data,
             aes(x = UMAP_1, y = UMAP_2, col = digit), size = 0.25)+
  geom_text_repel(data = umap_centers,
            aes(x = UMAP_1, y = UMAP_2, label = digit), 
            min.segment.length = 0, size = 3.6)+
  theme_bw(base_size = 10)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4, override.aes = list(size=2)))+
  scale_color_distiller(palette = "Spectral")

g_umap
```

```{r}
g_digits_plot <- (g_digits|g_umap)+patchwork::plot_layout(widths = c(1,1.6))
ggsave(g_digits_plot, filename = "manuscript_data/digits_umap.svg",
       device = "svg",width = 4.5, height = 2.25)
```



This also holds for t-SNE plots:

```{r, fig.width=5, fig.height=3.25, fig.align='center', echo = T}
tsne_plot <- Rtsne::Rtsne(X = digits[,1:64],
                          perplexity = 50, 
                          theta = 0.5, 
                          check_duplicates = TRUE,
                          pca = FALSE, 
                          partial_pca = FALSE, 
                          max_iter = 1000,
                          verbose = getOption("verbose", FALSE), 
                          is_distance = FALSE,
                          pca_center = F, 
                          pca_scale = F,
                          normalize = F, 
                          momentum = 0.5, 
                          final_momentum = 0.8, 
                          eta = 200,
                          exaggeration_factor = 12, 
                          num_threads = 10)
```


```{r, fig.width=5, fig.height=3.25, fig.align='center', echo = T}
tsne_data <- data.frame(digit = digit_classes,
                        TSNE_1 = tsne_plot$Y[, 1],
                        TSNE_2 = tsne_plot$Y[, 2])
tsne_data$closest_cluster <- NA
tsne_centers <- merge(x = aggregate(TSNE_1~digit, 
                                    data = tsne_data, FUN = median),
                      y = aggregate(TSNE_2~digit, 
                                    data = tsne_data, FUN = median),
                      by = "digit")

g_tsne <- ggplot()+
  geom_point(data = tsne_data,
             aes(x = TSNE_1, y = TSNE_2, col = digit), size = 0.25)+
  geom_text_repel(data = tsne_centers,
            aes(x = TSNE_1, y = TSNE_2, label = digit), 
            min.segment.length = 0, size = 3)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))+
  scale_color_distiller(palette = "Spectral")

g_tsne
```



```{r}
b <- get_k(B = 10, 
           cv_prop = 1, 
           ks = 1:20,
           x = as.matrix(digits[,1:64]),#A,
           n_start = 50, 
           iter_max = 200, 
           cores = 20,
           kmeans_algorithm = "MacQueen",
           B_gap = 5)
```



```{r}
g0 <- ggplot(data = b$sil_stats_summary)+
  geom_point(aes(x = k, y = sil_mean), size = 1)+
  geom_errorbar(aes(x = k, y = sil_mean, ymin = L95, ymax = H95), width = 0.1)+
  ggtitle(label = '', subtitle = "Silhouette")+
  ylab(label = "Mean Silhouette")|
ggplot(data = b$gap_stats_summary)+
  geom_point(aes(x = k, y = gap_mean), size = 1)+
  geom_errorbar(aes(x = k, y = gap_mean, ymin = L95, ymax = H95), width = 0.1)+
  ggtitle(label = '', subtitle = "Gap")+
  ylab(label = "Mean Gap")|
ggplot(data = b$wss_stats_summary)+
  geom_point(aes(x = k, y = wss_mean), size = 1)+
  geom_errorbar(aes(x = k, y = wss_mean, ymin = L95, ymax = H95), width = 0.1)+
  ggtitle(label = '', subtitle = "WSS")+
  ylab(label = "Mean WSS")+
  scale_y_log10()+
  annotation_logticks(base = 10, sides = "l")
```


```{r, fig.width=9, fig.height=3, fig.align='center'}
g0
```



```{r}
# Perform clustering to get data for scBubbletree
k10 <- get_bubbletree(x = as.matrix(digits[,1:64]),
                     k = 10,
                     seed = 1234,
                     cores = 20,
                     B = 200,
                     N_eff = 100,
                     verbose = F,
                     n_start = 100,
                     iter_max = 200,
                     round_digits = 1,
                     show_branch_support = T)
```


```{r, fig.width=4, fig.height=5, fig.align='center', echo=T}
k10$tree
```



```{r, echo=T}
w1 <- get_cat_feature_tiles(d = k10,
                            a = as.character(digit_classes),
                            feature_composition = T,
                            round_digits = 1,
                            rotate_x_axis = F,
                            show_hclust = F)
```


```{r, fig.width=8, fig.height=5, fig.align='center', echo=T}
(k10$tree|w1$w)+patchwork::plot_layout(ncol = 2, widths = c(1, 1))
```



## Gini impurity index

```{r}
# gini
get_gini(labels = as.character(digit_classes), 
         clusters = k10$cluster)
```


```{r, echo = T}
gini_boot <- get_gini_k(labels = as.character(digit_classes),
                           get_k_obj = b)
```

```{r, fig.width=4, fig.height=3, fig.align='center', echo=T}
g1 <- ggplot(data = gini_boot$total_gini_summary)+
  geom_point(aes(x = k, y = total_gini_mean), size = 1)+
  geom_errorbar(aes(x = k, y = total_gini_mean, ymin = L95, 
                    ymax = H95), width = 0.1)+
  ggtitle(subtitle = "Gini impurity", label = '')+
  ylab(label = "Mean impurity")

g1
```



## Are distances between cells preserved?

local = yes; long-range = no

```{r, echo = F, results='hide'}

# C = vector clusters of points
# tree_dist = matrix of cluster-to-cluster distance (e.g. from phylo)
get_d <- function(A, U_A, T_A, B, verbose=F) {
  
  get_euc <- function(x, y) {
    return(sqrt(sum((x-y)^2)))
  }
  
  get_pair_euc <- function(x, A, U_A, T_A) {
    
    if(x %% 1000 == 0) {
      cat(x, "\n")
    }
    
    j <- sample(x = 1:nrow(A), size = 2, replace = T)
    a_euc <- get_euc(A[j[1],], A[j[2],])
    u_euc <- get_euc(U_A[j[1],], U_A[j[2],])
    t_euc <- get_euc(T_A[j[1],], T_A[j[2],])
    
    return(data.frame(a_euc = a_euc, 
                      u_euc = u_euc, 
                      t_euc = t_euc))
  }
  
  o <- lapply(X = 1:B, 
              FUN = get_pair_euc, 
              A = A, 
              U_A = U_A, 
              T_A = T_A)
  
  o <- do.call(rbind, o)
  return(o)
}

```


```{r, echo = F, results='hide'}

pair_dist <- get_d(B = (10^4),
                   A = digits[, 1:64],
                   U_A = umap_data[, c("UMAP_1", "UMAP_2")],
                   T_A = tsne_data[, c("TSNE_1", "TSNE_2")],
                   verbose = T)

```


```{r, fig.width=4, fig.height=4, fig.align='center', echo = T}
g_pairs_umap <- ggplot(data = pair_dist)+
  geom_point(aes(y = a_euc, x = u_euc), size = 0.5)+
  geom_density_2d(aes(y = a_euc, x = u_euc), 
                  size = 0.5, color = "orange")+
  ylab(label = "Euclidean distance in PCA space")+
  xlab(label = "Euclidean distance in 2D UMAP space")

g_pairs_umap
```



```{r, fig.width=4, fig.height=4, fig.align='center', echo = T}
g_pairs_tsne <- ggplot(data = pair_dist)+
  geom_point(aes(y = a_euc, x = t_euc), size = 0.5)+
  geom_density_2d(aes(y = a_euc, x = t_euc), 
                  size = 0.5, color = "orange")+
  ylab(label = "Euclidean distance in PCA space")+
  xlab(label = "Euclidean distance in 2D t-SNE space")

g_pairs_tsne
```



```{r, echo=F, results='hide'}
ggsave(plot = g_pairs_umap,
       filename = "manuscript_data/distance_scaling_UMAP_C.png",
       device = "png",
       width = 3,
       height = 3)

ggsave(plot = g_pairs_tsne,
       filename = "manuscript_data/distance_scaling_TSNE_C.png",
       device = "png",
       width = 3,
       height = 3)
```



# Updating bubbles

```{r}

```








