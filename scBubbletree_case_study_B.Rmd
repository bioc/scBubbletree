---
title: "Case study B: Exploring scRNA-seq data with scBubbletree"
author: "SK"
output: 
  rmarkdown::html_document:
    toc: true
    toc_depth: 1
vignette: >
  %\VignetteIndexEntry{}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r, include = FALSE}
source(file = "~/Rutil/Init_Rpack.R")
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = F,
                      comment = F, 
                      warning = F, 
                      message = F)
```


This vignette introduces `scBubbletree`, a transparent methodology for single 
cell RNA-seq data exploration based on well established methods clustering 
and visualization. We will demonstrate the functionality of `scBubbletree` 
by analyzing a large dataset of human PBMCs (Case studies B), while also 
showing how to integrate `scBubbletree` with existing pipelines for scRNA-seq 
analysis e.g. based on Seurat.

To run this vignette we need several R-packages. Load them now:

```{r, echo = T, results='hide'}
source(file = "../Rutil/Graphics.R")

source(file = "../scBubbletree/R/util.R")
source(file = "../scBubbletree/R/main.R")
source(file = "../scBubbletree/R/annotation.R")
```


```{r, echo = T, results='hide'}
library(cluster, "/usr/local/lib/R/site-library")
library(Seurat, lib.loc = lib.loc)
library(ggplot2, lib.loc = lib.loc)
library(reshape2, lib.loc = lib.loc)
library(parallel, lib.loc = lib.loc)
library(ape, "/usr/local/lib/R/site-library")
library(ggtree, lib.loc = lib.loc)
library(org.Hs.eg.db, lib.loc = lib.loc)
library(bluster, lib.loc = lib.loc)
library(SummarizedExperiment, lib.loc = lib.loc)
library(ggrepel, lib.loc = lib.loc)
```


```{r}
redo_case_b <- F
```


# Case study B: 161,000 PBMCs from 8 healthy donors [^2],[^3]

## Data 

In this case study we will analyze scRNA-seq dataset of approximately 161,000 
PBMCs derived from 8 healthy donors, collected at three timepoints and sequenced
by 10x Genomics protocol. This is a large and complex scRNA-seq dataset, perfect
for demonstrating the advantageS of `scBubbletree` over qualitative analyses 
e.g. based on 2D UMAPs.

In addition to gene expression data, this dataset reports for each cell a cell 
type prediction at three levels of resolution (*l1*, *l2* and *l3*). The cell 
types have been predicted based on marker genes, and we will use them as 
categorical cell annotations. As this dataset is part of a larger CITE-seq
experiment, the cell type predictions are made based on scRNA-seq derived
gene expressions and also on the cell-surface protein expression levels of up
to 228 marker proteins.

In essence, we will perform the same steps as in *Case study A*:

  1. determine `k` $\rightarrow$ with $f:$ `get_k`
  2. perform clustering and generate dendrogram $\rightarrow$ with 
  $f:$ `get_bubbletree`
  3. inspect the dendrogram structure and annotate it with categorical and 
  quantitative cell meta data $\rightarrow$ with $fs:$ 
  `get_cat_feature_tiles`,`get_num_feature_tiles`,`get_num_feature_violins`
  4. assess the model: criticize the results $\rightarrow$ with $f_s:$
  `update_bubbletree`, `get_gini`, `get_gini_k`
  5. if necessary modify `k` and go back to 2.

The raw gene expressions have already been preprocessed with `Seurat`. SCT 
transformation was used for normalization, followed by principal component 
analysis for dimensionality reduction. 15 lower-space features have been 
extracted and used to generate a 2D UMAP.

Lets load the data.

```{r, echo=T}
# To get the data used in this case study do the following steps:
# 1. download reference data from vignette:
# https://satijalab.org/seurat/articles/multimodal_reference_mapping.html
# 2. load SeuratDistk
# library(SeuratDisk, lib.loc = lib.loc)
# d <- LoadH5Seurat("~/BubbleMap/raw_data/Hao_2021/pbmc_multimodal.h5seurat")
# save(d, file = "raw_data/Hao_2021/Hao_2021.RData")
```


```{r, echo=T}
# d <- get(load(file = "raw_data/Hao_2021/Hao_2021.RData"))
# d[["mt"]] <- PercentageFeatureSet(d, pattern = "^MT-")
# d@reductions$apca <- NULL
# d@reductions$aumap <- NULL
# d@reductions$spca <- NULL
# d@reductions$wnn.umap <- NULL
# d@reductions$umap <- NULL
```


```{r}
# d <- RunUMAP(object = d, dims = 1:15, reduction = "pca")
# d <- RunTSNE(object = d, dims = 1:15, reduction = "pca")
# save(d, file = "raw_data/Hao_2021/Hao_2021.RData")
```


```{r}
d <- get(load(file = "raw_data/Hao_2021/Hao_2021.RData"))
```



Lets look at the number of cells per donor at a given sampling time:

```{r, echo = T}
table(d@meta.data$time, d@meta.data$donor)
```

Also, we can show the number of cells per donor and predicted cell type at the 
lowest resolution (*l1*):

```{r, echo=T}
table(d@meta.data$celltype.l1, d@meta.data$donor)
```

How many distinct *cell types* are there at each resolution?

```{r, echo=T}
length(unique(d@meta.data$celltype.l1))
length(unique(d@meta.data$celltype.l2))
length(unique(d@meta.data$celltype.l3))
```



Next we will show the 2D UMAP. Cells are color coded according to their 
cell type predictions resolution level *l1* (left UMAP) and *l2* (right 
UMAP).



```{r, fig.width=6, fig.height=4, fig.align='center', echo=T}
umap_data <- cbind(d@meta.data, d@reductions$umap@cell.embeddings)
umap_data$closest_cluster <- NA

umap_centers <- merge(x = aggregate(UMAP_1~celltype.l1, data = umap_data, FUN = median),
                      y = aggregate(UMAP_2~celltype.l1, data = umap_data, FUN = median),
                      by = "celltype.l1")

g_umap <- ggplot()+
  geom_point(data = umap_data,
             aes(x = UMAP_1, y = UMAP_2, col = celltype.l1), size = 0.25)+
  geom_text_repel(data = umap_centers,
            aes(x = UMAP_1, y = UMAP_2, label = celltype.l1), 
            min.segment.length = 0, size = 2)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))

g_umap
```


```{r, results='hide', echo=FALSE}
ggsave(plot = g_umap, 
       filename = "manuscript_data/UMAP_B_lv1.pdf",
       device = "pdf",
       width = 4,
       height = 3)
ggsave(plot = g_umap, 
       filename = "manuscript_data/UMAP_B_lv1.png",
       device = "png",
       dpi = 600,
       width = 4,
       height = 3)
```


```{r, fig.width=6, fig.height=4, fig.align='center', echo=T}
umap_data <- cbind(d@meta.data, d@reductions$umap@cell.embeddings)
umap_data$closest_cluster <- NA

umap_centers <- merge(x = aggregate(UMAP_1~celltype.l2, data = umap_data, FUN = median),
                      y = aggregate(UMAP_2~celltype.l2, data = umap_data, FUN = median),
                      by = "celltype.l2")

g_umap <- ggplot()+
  geom_point(data = umap_data,
             aes(x = UMAP_1, y = UMAP_2, col = celltype.l2), size = 0.25)+
  geom_text_repel(data = umap_centers,
            aes(x = UMAP_1, y = UMAP_2, label = celltype.l2), 
            min.segment.length = 0, size = 2)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))

g_umap
```


```{r, results='hide', echo=FALSE}
ggsave(plot = g_umap, 
       filename = "manuscript_data/UMAP_B_lv2.pdf",
       device = "pdf",
       width = 4,
       height = 3)
ggsave(plot = g_umap, 
       filename = "manuscript_data/UMAP_B_lv2.png",
       device = "png",
       dpi = 600,
       width = 4,
       height = 3)
```




```{r, fig.width=6, fig.height=4, fig.align='center', echo=T}
tsne_data <- cbind(d@meta.data, d@reductions$tsne@cell.embeddings)
tsne_data$closest_cluster <- NA

tsne_centers <- merge(x = aggregate(tSNE_1~celltype.l2, data = tsne_data, FUN = median),
                      y = aggregate(tSNE_2~celltype.l2, data = tsne_data, FUN = median),
                      by = "celltype.l2")

g_tsne <- ggplot()+
  geom_point(data = tsne_data,
             aes(x = tSNE_1, y = tSNE_2, col = celltype.l2), size = 0.25)+
  geom_text_repel(data = tsne_centers,
            aes(x = tSNE_1, y = tSNE_2, label = celltype.l2), 
            min.segment.length = 0, size = 2)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))

g_tsne
```


```{r, echo=F, results='hide'}
ggsave(plot = g_tsne, 
       filename = "manuscript_data/TSNE_B_lv1.pdf",
       device = "pdf",
       width = 4,
       height = 3)

ggsave(plot = g_tsne, 
       filename = "manuscript_data/TSNE_B_lv1.png",
       device = "png",
       width = 4,
       height = 3)
```

```{r, fig.width=6, fig.height=4, fig.align='center', echo=T}
tsne_data <- cbind(d@meta.data, d@reductions$tsne@cell.embeddings)
tsne_data$closest_cluster <- NA

tsne_centers <- merge(x = aggregate(tSNE_1~celltype.l2, data = tsne_data, FUN = median),
                      y = aggregate(tSNE_2~celltype.l2, data = tsne_data, FUN = median),
                      by = "celltype.l2")

g_umap <- ggplot()+
  geom_point(data = tsne_data,
             aes(x = tSNE_1, y = tSNE_2, col = celltype.l2), size = 0.25)+
  geom_text_repel(data = tsne_centers,
            aes(x = tSNE_1, y = tSNE_2, label = celltype.l2), 
            min.segment.length = 0, size = 2)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))

g_umap
```


```{r, results='hide', echo=FALSE}
ggsave(plot = g_umap, 
       filename = "manuscript_data/UMAP_B_lv2.pdf",
       device = "pdf",
       width = 4,
       height = 3)
ggsave(plot = g_umap, 
       filename = "manuscript_data/UMAP_B_lv2.png",
       device = "png",
       dpi = 600,
       width = 4,
       height = 3)
```








## Challenges with 2D UMAP based scRNA-seq data exploration

Now that the UMAP contains more than 161,000 cells from a heterogeneous tissue, 
we start to see the challenges associated with this approach: 
  
  1. massive overplotting
    
      * limited visibility: the cells (points) form blobs of cells 
      $\rightarrow$ some points are covered by others
      * even at resolution level *l1* we have difficulty to distinguish 
      between cell types and their colors. This is quite more challenging for 
      level *l2* and *l3* (not shown)
      * increasing the number of cells in the dataset, which is likely to 
      happen as throughput of scRNA-seq techniques improves, will make the 
      problem even worse
      * comparison of 2D UMAPs between studies difficult -> UMAP rotation, 
      colors, cell order (which cell is shown on the top/bottom) affects 
      interpretation
  
  2. lack of compositional information
      * it is nearly impossible to ascertain the absolute/relative cell 
      frequencies in e.g. cell types, samples, timepoints
      * impossible to tell whether the samples are equally mixed across the 
      cell types or if there are some systematic biases. 
      * we could generate 8 x 3 separate UMAPs for each pair of donor and 
      timepoint -> difficult to interpret due to 1. + only major deviations 
      will be noticeable.
      
  3. qualitative analysis
      * distances between cell types should not be interpreted in Euclidean 
      distance sense -> cell type structure difficult to discern from 2D UMAP
      

## scBubbletree approach

Now lets turn to `scBubbletree`. As earlier, our first goal is to determine `k` 
for the clustering of matrix $A^{n \times f}$, which represents the low-
dimensional feature space of the normalized gene expression matrix. We will 
use the first $f$=15 PCA dimensions as features. We selected $f$=15 based on 
the elbow plot below.


```{r, fig.width=4, fig.height=3}
var_explained <- ((d[["pca"]]@stdev)^2)/d[["pca"]]@misc$total.variance

g_var_explained <- ggplot(data = data.frame(var_explained = var_explained*100,
                                            PC = 1:length(var_explained)))+
  geom_point(aes(y = var_explained, x = PC), size = 1)+
  ylab(label = "Variance explained [%]")

g_var_explained

ggsave(plot = g_var_explained, 
       filename = "manuscript_data/Var_explained_PCA_B.pdf",
       device = "pdf",
       width = 3,
       height = 2)
```



```{r, echo = T}
# This is the main input of scBubbletree 
# -> matrix A with n=cells, f=features (from PCA)
A <- d@reductions$pca@cell.embeddings[, 1:15]
```


```{r, echo = T}
# meta data
meta <- d@meta.data
```


```{r, echo = T}
# quantitative features (gene expressions of marker genes) to be used later on:
# * GNLY, NKG7:	NK cells
# * IL7R:	CD4 T cells
# * CD8A:	CD8 T cells
# * MS4A1:	B cells
# * CD14, LYZ:	CD14+ Monocytes
# * FCGR3A, MS4A7:	FCGR3A+ Monocytes
# * FCER1A, CST3:	Dendritic Cells
# * PPBP:	Megakaryocytes
as <- as.matrix(t(d@assays$SCT@data[
  rownames(d@assays$SCT@data) %in% 
    c("IL7R", 
      "CD14", "LYZ", 
      "MS4A1", 
      "CD8A", 
      "GNLY", "NKG7",
      "FCGR3A", "MS4A7",
      "FCER1A", "CST3",
      "PPBP"), ]))
```


```{r}
# cleanup
rm(d)
gc()
```


We will once again use the function `get_k` for clustering. Notice the modified 
parameter *cv_prop=0.2*, for faster execution of this large dataset:

```{r, fig.width=4, fig.height=3, echo = T}

if(redo_case_b) {
  # Determine appropriate number of clusters (k)
  b <- get_k(B = 10,
             cv_prop = 0.1, # use 20% for gap stat.
             ks = seq(from = 1, to = 40, by = 1),
             x = A,
             n_start = 100,
             iter_max = 200,
             cores = 20,
             mini_output = F,
             approx_silhouette = F,
             kmeans_algorithm = "MacQueen",
             B_gap = 5)
  
  if(dir.exists("case_study_B")==F) {
    dir.create("case_study_B")
  }
  save(b, file = "case_study_B/b.RData")
  cat("Done.")
} else {
  b <- get(load("~/scBubbletree/case_study_B/b.RData"))
}

```

We see a more complex silhouette curve. This is normal given the complexity
in our dataset, which is composed of many cell types with high and low relative
frequencies. We see a maximum silhouette index at `k=5`. The index then drops 
sharply until `k=11`, followed by shallow increase until `k=14` after the 
silhouette starts once again to decrease.

Elbows are not easy to detect from the Gap and WSS curves. It is quite evident,
however, that both curves flatten at around `k=15` to `k=20`. 


```{r}
g0 <- ggplot(data = b$sil_stats_summary)+
  geom_point(aes(x = k, y = sil_mean), size = 1)+
  geom_errorbar(aes(x = k, y = sil_mean, ymin = L95, ymax = H95), width = 0.1)+
  ggtitle(label = '', subtitle = "Silhouette")+
  ylab(label = "Mean Silhouette")|
ggplot(data = b$gap_stats_summary)+
  geom_point(aes(x = k, y = gap_mean), size = 1)+
  geom_errorbar(aes(x = k, y = gap_mean, ymin = L95, ymax = H95), width = 0.1)+
  ggtitle(label = '', subtitle = "Gap")+
  ylab(label = "Mean Gap")|
ggplot(data = b$wss_stats_summary)+
  geom_point(aes(x = k, y = wss_mean), size = 1)+
  geom_errorbar(aes(x = k, y = wss_mean, ymin = L95, ymax = H95), width = 0.1)+
  ggtitle(label = '', subtitle = "WSS")+
  ylab(label = "Mean WSS")+
  scale_y_log10()+
  annotation_logticks(base = 10, sides = "l")
```


```{r, fig.width=10, fig.height=3, fig.align='center'}
g0
```








## Lets try `k=18`


```{r, echo=T}

if(redo_case_b) {
  k18 <- get_bubbletree(x = A,
                        k = 18,
                        n_start = 500,
                        iter_max = 1000,
                        seed = 4321,
                        cores = 20,
                        B = 200,
                        N_eff = 200,
                        verbose = FALSE,
                        round_digits = 1,
                        show_branch_support = T,
                        show_simple_count = T)
  save(k18, file = "case_study_B/k18.RData")
} else {
  k18 <- get(load("~/scBubbletree/case_study_B/k18.RData"))
}

```




<!-- ```{r, echo=T} -->

<!-- if(redo_case_b) { -->
<!--   # do clustering with k=15 -->
<!--   k15 <- get_bubbletree(x = A, -->
<!--                         k = 15, -->
<!--                         n_start = 500, -->
<!--                         iter_max = 1000, -->
<!--                         seed = 4321, -->
<!--                         cores = 20, -->
<!--                         B = 200, -->
<!--                         N_eff = 200, -->
<!--                         verbose = FALSE, -->
<!--                         round_digits = 1, -->
<!--                         show_branch_support = T, -->
<!--                         show_simple_count = T) -->
<!--   save(k15, file = "case_study_B/k15.RData") -->
<!-- } else { -->
<!--   k15 <- get(load("~/scBubbletree/case_study_B/k15.RData")) -->
<!-- } -->

<!-- ``` -->



<!-- ```{r, echo=T} -->

<!-- if(redo_case_b) { -->
<!--   k20 <- get_bubbletree(x = A, -->
<!--                         k = 20, -->
<!--                         n_start = 500, -->
<!--                         iter_max = 1000, -->
<!--                         seed = 4321, -->
<!--                         cores = 20, -->
<!--                         B = 200, -->
<!--                         N_eff = 200, -->
<!--                         verbose = FALSE, -->
<!--                         round_digits = 1, -->
<!--                         show_branch_support = T, -->
<!--                         show_simple_count = T) -->
<!--   save(k20, file = "case_study_B/k20.RData") -->
<!-- } else { -->
<!--   k20 <- get(load("~/scBubbletree/case_study_B/k20.RData")) -->
<!-- } -->

<!-- ``` -->


Summary of the bubbletree:

  * the lymphocyte and monocyte branches of bubbles are well defined. Within
  branch structures are biologically meaningful
  * bubble 2 is the largest one in the tree and appears to be enriched with
  naive T-cells and Tregs, but also hematopoietic stem and 
  progenitor cells (HSPC) $\rightarrow$ additional clustering might be necessary
  * other T-cells, such as effector, central memory and cytotoxic T-cells, are 
  enriched in the remaining bubbles 1, 8, 14 of the same branch.
  * NK-cells are contained in bubble 7, shown as an outgroup of lymphocytes
  * B-cells (naive, memory, intermediate and plasmablasts) are found in a common
  branch containing bubble 3 and 13
  * CD14+ and CD16+ monocytes and different types of DCs are contained in a
  separate branch of monocyte bubbles. Surprisingly, these bubbles are also 
  enriched with doublets
  * most branches have high (complete) bootstrap support. This is not the case
  for the branch connecting bubble 8 and 14 (50% support).
  * cells from smaller PBMCs subtypes, such as platelets and erythrocytes, are 
  found as separate bubbles shown as outgroups 
  * in summary, the clustering algorithm with $k=15$ recovers most *l2* 
  resolution cell types and produces a biologically meaningful bubbletree 
  topology
  
```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
c1 <- meta$celltype.l1
c2 <- gsub(pattern = "Proliferating", replacement = 'prolif.', meta$celltype.l2)
c2 <- gsub(pattern = "CD56bright", replacement = 'CD56', x = c2)
donor <- meta$donor

# create tile plots
w0 <- get_cat_feature_tiles(d = k18,
                            a = c1, # res = 1
                            feature_composition = T,
                            round_digits = 0,
                            show_hclust = F,
                            tile_text_size = 2.75)


w1 <- get_cat_feature_tiles(d = k18,
                            a = c2, # res = 2
                            feature_composition = T,
                            round_digits = 0,
                            show_hclust = F,
                            tile_text_size = 2.25)


w2 <- get_cat_feature_tiles(d = k18,
                            a = donor,
                            feature_composition = T,
                            round_digits = 0,
                            show_hclust = F,
                            tile_text_size = 2.75)
```






```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
c2 <- gsub(pattern = "Proliferating", replacement = 'prolif.', meta$celltype.l2)
c2 <- gsub(pattern = "CD56bright", replacement = 'CD56', x = c2)


w1 <- get_cat_feature_tiles(d = k18,
                            a = c2,
                            feature_composition = T,
                            round_digits = 0,
                            show_hclust = F,
                            tile_text_size = 2.25)


w2 <- get_cat_feature_tiles(d = k18,
                            a = c2,
                            feature_composition = F,
                            round_digits = 0,
                            show_hclust = F,
                            tile_text_size = 2.25)
```

```{r, echo=F, results='hide'}
fig_3 <- (w1$w)/(w2$w)
fig_3

ggsave(plot = fig_3,
       filename = "manuscript_data/Fig_3.svg",
       device = "svg",
       width = 5.2,
       height = 6.8)
```



```{r, echo=F, results='hide'}
gini_l1 <- get_gini_k(labels = meta$celltype.l1, get_k_obj = b)
gini_l2 <- get_gini_k(labels = meta$celltype.l2, get_k_obj = b)
gini_l3 <- get_gini_k(labels = meta$celltype.l3, get_k_obj = b)

l1 <- gini_l1$total_gini_summary
l1$level <- "l1"

l2 <- gini_l2$total_gini_summary
l2$level <- "l2"

l3 <- gini_l3$total_gini_summary
l3$level <- "l3"

l_summary <- rbind(l1, l2, l3)

g_gini <- ggplot(data = l_summary)+
  geom_point(aes(x = k, y = total_gini_mean, col = level), size = 0.5)+
  geom_errorbar(aes(x = k, y = total_gini_mean, ymin = L95, 
                    ymax = H95, col = level), width = 0.2)+
  scale_color_manual(name = "R",
                     values = c("black", "#787777", "gray"))+
  theme(legend.position = c(0.8, 0.7))+
  ylab(label = "Mean impurity")

g_gini
```


```{r, echo=F, results='hide'}
g0 <- ggplot(data = b$sil_stats_summary)+
  geom_point(aes(x = k, y = sil_mean), size = 0.5)+
  geom_errorbar(aes(x = k, y = sil_mean, ymin = L95, ymax = H95), width = 0.2)+
  ggtitle(label = '', subtitle = "Silhouette")+
  ylab(label = "Mean Silhouette")|
ggplot(data = b$gap_stats_summary)+
  geom_point(aes(x = k, y = gap_mean), size = 0.5)+
  geom_errorbar(aes(x = k, y = gap_mean, ymin = L95, ymax = H95), width = 0.2)+
  ggtitle(label = '', subtitle = "Gap")+
  ylab(label = "Mean Gap")|
ggplot(data = b$wss_stats_summary)+
  geom_point(aes(x = k, y = wss_mean), size = 0.5)+
  geom_errorbar(aes(x = k, y = wss_mean, ymin = L95, ymax = H95), width = 0.2)+
  ggtitle(label = '', subtitle = "WSS")+
  ylab(label = "Mean WSS")+
  scale_y_log10()+
  annotation_logticks(base = 10, sides = "l")


fig_2_bottom <- (k18$tree|w2$w|w0$w)+patchwork::plot_layout(widths = c(2, 3, 3))
fig_2_top <- g0
fig_2 <- (fig_2_top/fig_2_bottom)+patchwork::plot_layout(heights = c(1, 4))+patchwork::plot_annotation(tag_levels = 'A')

ggsave(plot = fig_2,
       filename = "manuscript_data/Fig_2.svg",
       device = "svg",
       width = 7.5,
       height = 7)
```







```{r, echo = F, results='hide', fig.width=7}
# This function build the nummeric annotations plot
a <- data.frame(mt_prop = meta$mt,
                count_RNA = meta$nCount_RNA,
                count_genes = meta$nFeature_RNA)

sup_w <- (get_num_feature_violins(d = k18,
                                 as = data.frame(MT = a$mt_prop),
                                 plot_title = "",
                                 show_cells = F)$w|
            get_num_feature_violins(d = k18,
                                 as = data.frame(count_RNA = a$count_RNA),
                                 plot_title = "",
                                 show_cells = F)$w|
            get_num_feature_violins(d = k18,
                                 as = data.frame(count_genes = a$count_genes),
                                 plot_title = "",
                                 show_cells = F)$w
          )


sup_w
ggsave(plot = sup_w,
       filename = "manuscript_data/Fig_2_QC.svg",
       device = "svg",
       width = 6,
       height = 6)
```


Interestingly, the bubbles 1 and 2 contain many different cell types. Additional
clustering of these bubbles might be necessary.

<!-- ## Bubble update -->

<!-- `scBubbletree` can perform targeted clustering of cells within specific bubbles.  -->
<!-- This can be achieved with the function `update_bubbletree`. Lets update  -->
<!-- bubbles 1 and 2 into two sub-bubbles. -->

<!-- **Important remark**: the function `update_bubbletree` should be used to  -->
<!-- explore the clustering in order to select an appropriate `k` and to explain the  -->
<!-- segmentation.  -->

<!-- ```{r, echo=T} -->

<!-- if(redo_case_b) { -->
<!--   # do clustering with k=15 -->
<!--   u_k18 <- update_bubbletree(btd = k18, -->
<!--                              updated_bubbles = c("2", "1"), -->
<!--                              k = 4, -->
<!--                              cores = 20) -->
<!--   save(u_k18, file = "case_study_B/u_k18.RData") -->
<!-- } else { -->
<!--   u_k18 <- get(load("~/scBubbletree/case_study_B/u_k18.RData")) -->
<!-- } -->

<!-- ``` -->


<!-- ```{r, fig.width=12, fig.height=8, fig.align='center', echo=T} -->
<!-- # create tile plot -->
<!-- w2 <- get_cat_feature_tiles(d = u_k18, -->
<!--                             a = a, -->
<!--                             feature_composition = T, -->
<!--                             round_digits = 0, -->
<!--                             show_hclust = F) -->

<!-- (u_k18$tree|w2$w)+patchwork::plot_layout(ncol = 2, widths = c(4, 9)) -->
<!-- ``` -->


## Gini index

Can we show quantitatively that by increasing `k` we get "better" clustering 
in a semi-supervised way? Yes, we can use the Gini impurity index.

For this we will integrate the results obtained by function `get_k` with *l1*, 
*l2* and *l3* cell type predictions (labels), and show quantitatively the 
change in Gini index as a function of `k`. This is done with the function 
`get_gini_k`. One potential caveat of this approach is that some of the 
predictions might be inaccurate. 

Lets invoke the function `get_gini_k` and pass the object `b` obtained 
earlier together with the cell type predictions:

```{r, echo = T}
b <- get(load("~/scBubbletree/case_study_B/b.RData"))
gini_l1 <- get_gini_k(labels = meta$celltype.l1,
                      get_k_obj = b)
gini_l2 <- get_gini_k(labels = meta$celltype.l2,
                      get_k_obj = b)
gini_l3 <- get_gini_k(labels = meta$celltype.l3,
                      get_k_obj = b)
```


We next plot the Gini scores for the labels at resolution *l1*, *l2* and *l3*.

```{r, fig.width=3, fig.height=3, fig.align='center'}
l1 <- gini_l1$total_gini_summary
l1$level <- "l1"

l2 <- gini_l2$total_gini_summary
l2$level <- "l2"

l3 <- gini_l3$total_gini_summary
l3$level <- "l3"

l_summary <- rbind(l1, l2, l3)

g_gini <- ggplot(data = l_summary)+
  geom_point(aes(x = k, y = total_gini_mean, col = level, shape = level), size = 1)+
  geom_errorbar(aes(x = k, y = total_gini_mean, ymin = L95, 
                    ymax = H95, col = level), width = 0.1)+
  scale_color_manual(name = "R",
                     values = c("black", "#787777", "gray"))+
  scale_shape_manual(name = "R",
                     values = c(1, 2, 3))+
  theme(legend.position = c(0.8, 0.7))+
  ylab(label = "Gini impurity")+
  ylim(c(0,1))+
  xlab(label = "k-means clusters (k)")

g_gini
```


Summary of the above plot:
  
  * more abstract cell types can be segmented more accurately and the 
  resulting segmentation has lower total Gini impurity.
  * in each curve the total Gini impurity appears to decrease slowly for as 
  `k` approaches 20.
  * this indicates that our previous data-based indices provide meaningful results
  * important: finding the right $k$ also depends on the user's objectives



## Quantiative features

Gene expression annotations can also be integrated to better explain the 
bubbles and the tree structure. Lets visualize the mean gene expression of some 
marker genes in the bubbles:

  * GNLY, NKG7:	*NK cells*
  * IL7R:	*CD4 T cells*
  * CD8A:	*CD8 T cells*
  * MS4A1:	*B cells*
  * CD14, LYZ:	*CD14+ Monocytes*
  * FCGR3A, MS4A7:	*FCGR3A+ Monocytes*
  * FCER1A, CST3:	*Dendritic Cells*
  * PPBP:	*Megakaryocytes*


```{r, fig.width=8, fig.height=8, fig.align='center', echo=T}
# This function build the nummeric annotations plot
w3 <- get_num_feature_tiles(d = k18,
                            as = as,
                            plot_title = "",
                            round_digits = 1,
                            tile_text_size = 2.5)

# Plot
(k18$tree|w3$w)+patchwork::plot_layout(widths = c(1, 1))
```

Second, we can visualize the distribution of each marker gene in each bubble 
using violin plots with `get_num_feature_violins`. This function uses the same
input as `get_num_feature_tiles`. 

Lets invoke this function now.

```{r, fig.width=8, fig.height=9, fig.align='center', echo=T}
w4 <- get_num_feature_violins(d = k18,
                              as = as,
                              plot_title = "",
                              scales = 'free_x',
                              show_cells = F)


((k18$tree|w3$w)+patchwork::plot_layout(widths = c(1, 1)))/w4$w
```



```{r, echo=T, results='hide'}
# lets first create a variable showing pairs (donor x timepoint) 
a <- paste0(meta$donor, '_', meta$time)
a <- factor(x = a, levels = sort(unique(a)))
# categorical donor meta data
w5 <- get_cat_feature_tiles(d = k18,
                            a = a,
                            feature_composition = T,
                            round_digits = 0,
                            show_hclust = F,
                            disable_hclust = T,
                            tile_text_size = 2.5)

w5$w
```

```{r}
g_sup <- (((k18$tree|w3$w)+patchwork::plot_layout(widths = c(1, 1.3)))/w5$w)+
  patchwork::plot_layout(widths = c(1.5, 1))+
  patchwork::plot_annotation(tag_levels = 'A')

ggsave(plot = g_sup,
       filename = "manuscript_data/Fig_S2.svg",
       device = "svg",
       width = 7,
       height = 9)
```




```{r, fig.width=9, fig.height=8.5}
g <- (g0|g_gini)/((k18$tree|w1$w)+patchwork::plot_layout(widths = c(1.5,6)))+
  patchwork::plot_layout(heights = c(1, 4.5))+
  patchwork::plot_annotation(tag_levels = 'A')

ggsave(plot = g,
       filename = "manuscript_data/Fig_2.svg",
       device = "svg",
       width = 8,
       height = 8)

```







## Are distances between cells preserved?

local = yes; long-range = no

```{r, echo = F, results='hide'}

# C = vector clusters of points
# tree_dist = matrix of cluster-to-cluster distance (e.g. from phylo)
get_d <- function(A, U_A, T_A, B, verbose=F) {
  
  get_euc <- function(x, y) {
    return(sqrt(sum((x-y)^2)))
  }
  
  get_pair_euc <- function(x, A, U_A, T_A) {
    
    if(x %% 1000 == 0) {
      cat(x, "\n")
    }
    
    j <- sample(x = 1:nrow(A), size = 2, replace = T)
    a_euc <- get_euc(A[j[1],], A[j[2],])
    u_euc <- get_euc(U_A[j[1],], U_A[j[2],])
    t_euc <- get_euc(T_A[j[1],], T_A[j[2],])
    
    return(data.frame(a_euc = a_euc, 
                      u_euc = u_euc, 
                      t_euc = t_euc,
                      i = j[1],
                      j = j[2]))
  }
  
  o <- lapply(X = 1:B, 
              FUN = get_pair_euc, 
              A = A, 
              U_A = U_A, 
              T_A = T_A)
  
  o <- do.call(rbind, o)
  return(o)
}

```


```{r, echo = F, results='hide'}
meta$k <- k18$cluster

pair_dist <- get_d(B = 5*(10^4),
                   A = A[, 1:15],
                   U_A = umap_data[, c("UMAP_1", "UMAP_2")],
                   T_A = tsne_data[, c("tSNE_1", "tSNE_2")],
                   verbose = T)

pair_dist$i_k <- meta$k[pair_dist$i]
pair_dist$j_k <- meta$k[pair_dist$j]
pair_dist$comparison <- ifelse(test = pair_dist$i_k==pair_dist$j_k, 
                               yes = "w", no = "b")
```






```{r, fig.width=4, fig.height=4, fig.align='center', echo = T}
g_pairs_umap <- ggplot(data = pair_dist)+
  geom_point(aes(y = a_euc, x = u_euc, col = comparison), size = 0.25)+
  geom_density_2d(aes(y = a_euc, x = u_euc), col = "orange")+
  ylab(label = "Distance in PCA")+
  xlab(label = "Distance in 2D UMAP")+
  scale_color_manual(values = c("black", "darkgray"))+
  theme(legend.position = "none")

g_pairs_umap
```



```{r, fig.width=4, fig.height=4, fig.align='center', echo = T}
g_pairs_tsne <- ggplot(data = pair_dist)+
  geom_point(aes(y = a_euc, x = t_euc, col = comparison), size = 0.25)+
  geom_density_2d(aes(y = a_euc, x = t_euc), col = "orange")+
  ylab(label = "Distance in PCA")+
  xlab(label = "Distance in 2D t-SNE")+
  scale_color_manual(values = c("black", "darkgray"))+
  theme(legend.position = "none")

g_pairs_tsne
```





# Benchmarking: k-means, 2D UMAP/tSNE 

```{r, fig.width=7, fig.height=4.5}
umap_data$k <- k18$cluster
tsne_data$k <- k18$cluster

umap_k_centers <- merge(x = aggregate(UMAP_1~k, data = umap_data, FUN = median),
                      y = aggregate(UMAP_2~k, data = umap_data, FUN = median),
                      by = "k")
tsne_k_centers <- merge(x = aggregate(tSNE_1~k, data = tsne_data, FUN = median),
                      y = aggregate(tSNE_2~k, data = tsne_data, FUN = median),
                      by = "k")

g_clustering<-(((ggplot()+
  geom_point(data = umap_data,
             aes(x = UMAP_1, y = UMAP_2, col = as.character(k)), size = 0.25)+
  geom_text_repel(data = umap_k_centers,
            aes(x = UMAP_1, y = UMAP_2, label = as.character(k)), 
            min.segment.length = 0, size = 3)+
  theme(legend.position = "none")+
    scale_color_discrete(name = "cluster")+
  guides(colour = guide_legend(nrow = 2, override.aes = list(size=2))))|
  g_pairs_umap)/
((ggplot()+
  geom_point(data = tsne_data,
             aes(x = tSNE_1, y = tSNE_2, col = as.character(k)), size = 0.25)+
  geom_text_repel(data = tsne_k_centers,
            aes(x = tSNE_1, y = tSNE_2, label = as.character(k)), 
            min.segment.length = 0, size = 3)+
  theme(legend.position = "none")+
    scale_color_discrete(name = "cluster")+
  guides(colour = guide_legend(nrow = 2, override.aes = list(size=2))))|
  g_pairs_tsne))

g_clustering <- g_clustering+patchwork::plot_annotation(tag_level = 'A')
g_clustering

ggsave(plot = g_clustering,
       filename = "manuscript_data/Supplement_case_study_B.png",
       device = "png",
       width = 6.5,
       height = 4.5,
       dpi = 600)
```


```{r}
# save image
save.image(file = "case_study_B/workspace_image.RData")
```


```{r}
load(file = "case_study_B/workspace_image.RData")
```


```{r}

get_c <- function(d, res, B=20, reduction_type) {
  
  gini_summary <- c()
  for(b in 1:B) {
    # bootstrap IDs
    i <- sample(x = 1:nrow(d@meta.data),
                size = ceiling(x = nrow(d@meta.data)*0.1),
                replace = T)
    
    d@meta.data$i <- 0
    d@meta.data$i[i] <- 1
    
    # subset d
    d_tmp <- subset(d, subset = i == 1)
    
    # perform clustering
    d_tmp <- Seurat::FindNeighbors(object = d_tmp, 
                                   reduction = reduction_type,
                                   dims = 1:2)
    c <- FindClusters(object = d_tmp, 
                      resolution = 10^res)
    
    c <- as.character(c$seurat_clusters)
    c <- data.frame(b = b,
                    leuven_umap = c,
                    celltype.l1 = d_tmp$celltype.l1,
                    celltype.l2 = d_tmp$celltype.l2,
                    celltype.l3 = d_tmp$celltype.l3,
                    res_exp = res,
                    res = 10^as.numeric(res),
                    k = length(unique(c)))
    
    g1 <- get_gini(labels = c$celltype.l1,
                   clusters = c$leuven_umap)
    g2 <- get_gini(labels = c$celltype.l2,
                   clusters = c$leuven_umap)
    g3 <- get_gini(labels = c$celltype.l3,
                   clusters = c$leuven_umap)
    
    gini_summary <- rbind(gini_summary, 
                          data.frame(b = b,
                                     res = c$res[1],
                                     k = c$k[1],
                                     gini_l1 = g1$total_gini,
                                     gini_l2 = g2$total_gini,
                                     gini_l3 = g3$total_gini))
    
  }
  return(gini_summary)
}

```


```{r}
d <- get(load(file = "raw_data/Hao_2021/Hao_2021.RData"))
d@meta.data$i <- 1:nrow(d@meta.data)
res <- seq(from = -4, to = 1, by = 0.1)
leuven_umap <- mclapply(X = res, FUN = get_c, d = d, B = 10, 
                        mc.cores = 20, reduction_type = "umap")
names(leuven_umap) <- res
save(leuven_umap, file = "case_study_B/leuven_umap.RData")
```


```{r}
d <- get(load(file = "raw_data/Hao_2021/Hao_2021.RData"))
d@meta.data$i <- 1:nrow(d@meta.data)
res <- seq(from = -4, to = 1, by = 0.1)
leuven_tsne <- mclapply(X = res, FUN = get_c, d = d, B = 10, 
                        mc.cores = 10, reduction_type = "tsne")
names(leuven_tsne) <- res
save(leuven_tsne, file = "case_study_B/leuven_tsne.RData")
```


```{r}
leuven_umap <- get(load("~/scBubbletree/case_study_B/leuven_umap.RData"))
leuven_umap <- do.call(rbind, leuven_umap)

leuven_tsne <- get(load("~/scBubbletree/case_study_B/leuven_tsne.RData"))
leuven_tsne <- do.call(rbind, leuven_tsne)
```






```{r, fig.width=6.6, fig.height=3}
gini_umap <- merge(
  x = merge(
    x = aggregate(gini_l1~k, data = leuven_umap, FUN = mean),
    y = aggregate(gini_l2~k, data = leuven_umap, FUN = mean), by = "k"),
  y = aggregate(gini_l3~k, data = leuven_umap, FUN = mean), by = "k")

gini_tsne <- merge(
  x = merge(
    x = aggregate(gini_l1~k, data = leuven_tsne, FUN = mean),
    y = aggregate(gini_l2~k, data = leuven_tsne, FUN = mean), by = "k"),
  y = aggregate(gini_l3~k, data = leuven_tsne, FUN = mean), by = "k")

g_gini_umap_leuven <- ggplot(data = gini_umap)+
  geom_point(aes(x = k, y = gini_l1), col = "black", shape = 1, size = 1)+
  geom_point(aes(x = k, y = gini_l2), col = "#787777", shape = 2, size = 1)+
  geom_point(aes(x = k, y = gini_l3), col = "gray", shape = 3, size = 1)+
  xlim(c(0, 50))+
  ylab(label = "Gini impurity")+
  xlab(label = "Leuven UMAP clusters (k)")+
  ylim(c(0, 1))

g_gini_tsne_leuven <- ggplot(data = gini_tsne)+
  geom_point(aes(x = k, y = gini_l1), col = "black", shape = 1, size = 1)+
  geom_point(aes(x = k, y = gini_l2), col = "#787777", shape = 2, size = 1)+
  geom_point(aes(x = k, y = gini_l3), col = "gray", shape = 3, size = 1)+
  xlim(c(0, 50))+
  ylab(label = "Gini impurity")+
  xlab(label = "Leuven t-SNE clusters (k)")+
  ylim(c(0, 1))

g_gini_b <- g_gini|g_gini_umap_leuven|g_gini_tsne_leuven
```


```{r}
ggsave(plot = g_gini_b, 
       filename = "manuscript_data/g_gini_leuven_B.svg",
       device = "svg",
       width = 6.5,
       height = 3)
```




# References

[^1]: Tian, Luyi, et al. "Benchmarking single cell RNA-sequencing analysis 
pipelines using mixture control experiments." Nature methods 16.6 (2019): 
479-487.
[^2]: Hao, Yuhan, et al. "Integrated analysis of multimodal single-cell 
data." Cell 184.13 (2021): 3573-3587.
[^3]: https://satijalab.org/seurat/articles/multimodal_reference_mapping.html
[^4]: https://www.10xgenomics.com/resources/datasets/10-k-human-pbm-cs-5-v-2-0-chromium-x-2-standard-6-1-0
