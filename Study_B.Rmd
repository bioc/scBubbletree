---
title: "Study B: Exploring massive CITE-seq data from 161k PBMCs with scBubbletree"
author: "SK"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---


```{r, echo=F}
source(file = "~/Rutil/Init_Rpack.R")
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = F, 
                      comment = F, 
                      warning = F, 
                      message = F)
```


This vignette introduces `scBubbletree`, a transparent workflow for exploration
of single cell RNA-seq data. To run this vignette we need a few R-packages:


```{r, echo = T, eval = F, results='hide'}
library(scBubbletree)
library(Seurat)
library(ggrepel)
library(SeuratDisk)
```

```{r}
# source("R/annotation.R")
# source("R/main.R")
# source("R/util.R")
```



```{r, echo = F, results='hide'}
source(file = "~/Rutil/Graphics.R")
library(scBubbletree, lib.loc = lib.loc)
library(Seurat, lib.loc = lib.loc)
library(ggrepel, lib.loc = lib.loc)
library(SeuratDisk, lib.loc = lib.loc)
```


```{r, echo=F}
redo_case_b <- FALSE
```



## Data

In this case study we will analyze a scRNA-seq dataset of 161,764 cells 
peripheral blood mononuclear cells (PBMCs) from eight healthy volunteers 
enrolled in an HIV vaccine trial[^1]. Analysis of this data based on Seurat
is presented here[^2]

Sample collection and data processing details are provided in the respective 
publication. In the following we summarize the key workflow steps. Key data 
collection and processing steps are summarized in the following. Samples were 
collected at three time points: immediately before (day 0), 3 days, and 7 days 
following administration of a HIV vaccine. All samples were profiled using 
10x Chromium 3' protocol, followed by Illumina NovaSeq 6000 sequencing. 
Alongside the single cell transcriptomes, CITE-seq technology was used with up 
to 228 antibodies to profile cell-surface protein expression. 

This multimodal data was processed with a weighted nearest neighbor (WNN) 
procedure to identify different cellular states in PBMCs. Cell types were 
predicted by this approach for each cell at three levels of resolution: l1 
with 8 cell types and l2 with 31 cell types. The predictions are available 
as part of the meta data associated with the raw scRNA-seq data.

```{r, echo=T, eval=F}
# create directory
dir.create(path = "case_study_B/")


# 1. download reference data from vignette:
https://atlas.fredhutch.org/data/nygc/multimodal/pbmc_multimodal.h5seurat


# 2. load SeuratDisk
d <- LoadH5Seurat("case_study_B/pbmc_multimodal.h5seurat")
save(d, file = "case_study_B/Hao_2021.RData")


# 3. remove precomputed reductions
d <- get(load(file = "case_study_B/Hao_2021.RData"))
d[["mt"]] <- PercentageFeatureSet(d, pattern = "^MT-")
d@reductions$apca <- NULL
d@reductions$aumap <- NULL
d@reductions$spca <- NULL
d@reductions$wnn.umap <- NULL
d@reductions$umap <- NULL


# 4. run UMAP and t-SNE again
d <- RunUMAP(object = d, dims = 1:15, reduction = "pca")
d <- RunTSNE(object = d, dims = 1:15, reduction = "pca")
save(d, file = "case_study_B/Hao_2021.RData")
```


```{r}
d <- get(load(file = "case_study_B/Hao_2021.RData"))
```



Lets look at the number of cells per donor at a given sampling time:

```{r, echo = T}
table(d@meta.data$time, d@meta.data$donor)
```


We can show the number of cells per donor and predicted cell type from
annotation set *l1*

```{r, echo=T}
table(d@meta.data$celltype.l1, d@meta.data$donor)
```


... and also from annotation set *l2*

```{r, echo=T}
table(d@meta.data$celltype.l2, 
      d@meta.data$donor)
```


How many distinct *cell types* are there in each annotation set?

```{r, echo=T}
length(unique(d@meta.data$celltype.l1))
length(unique(d@meta.data$celltype.l2))
```



## scBubbletree inputs
   
We will analyze this data with `scBubbletree`. 

As first input `scBubbletree` uses matrix $A^{n\times f}$ which represents a 
low-dimensional projection of the original scRNA-seq data, with $n$ rows as 
cells and $f$ columns as low-dimension features. 

We will use the PCA projection generated by `Seurat` as $A$. In particular, we 
will use the first 15 principal components (PCs) as each additional PC appears
to explain negligible amount of variance in the data.

```{r, fig.width=4, fig.height=3, echo=T, fig.align='center'}
var_explained <- ((d[["pca"]]@stdev)^2)/d[["pca"]]@misc$total.variance

g_var_explained <- ggplot(data = data.frame(var_explained = var_explained*100,
                                            PC = 1:length(var_explained)))+
  geom_point(aes(y = var_explained, x = PC), size = 1)+
  ylab(label = "Variance explained [%]")+
  scale_y_log10()

g_var_explained
```


Subset the 15 first PCs

```{r, echo = T}
# This is the main input of scBubbletree -> matrix A
A <- d@reductions$pca@cell.embeddings[, 1:15]
```


```{r, echo = T}
# A has n=cells as rows, f=features as columns (e.g. from PCA)
dim(A)
```


We also need the meta data which includes information for each cell, such as 
cell ID, sample/subject name, cell type prediction labels and 2D t-SNE and UMAP
coordinates

```{r, echo = T}
# meta data
meta <- d@meta.data
meta$tSNE_1 <- d@reductions$tsne@cell.embeddings[, 1]
meta$tSNE_2 <- d@reductions$tsne@cell.embeddings[, 2]
meta$UMAP_1 <- d@reductions$umap@cell.embeddings[, 1]
meta$UMAP_2 <- d@reductions$umap@cell.embeddings[, 2]
```


We will also need the expressions of some key PBMC markers for some of the
downstream analyses

```{r, echo = T}
# quantitative features (gene expressions of marker genes) to be used later on:
# * GNLY, NKG7:	NK cells
# * IL7R:	CD4 T cells
# * CD8A:	CD8 T cells
# * MS4A1:	B cells
# * CD14, LYZ:	CD14+ Monocytes
# * FCGR3A, MS4A7:	FCGR3A+ Monocytes
# * FCER1A, CST3:	Dendritic Cells
# * PPBP:	Megakaryocytes
as <- t(as.matrix(d@assays$SCT@data[
  rownames(d@assays$SCT@data) %in% 
    c("IL7R", 
      "CD14", "LYZ", 
      "MS4A1", 
      "CD8A", 
      "GNLY", "NKG7",
      "FCGR3A", "MS4A7",
      "FCER1A", "CST3",
      "PPBP"), ]))
```


## scBubbletree algorithm

The `scBubbletree` workflow performs the following steps:
  
  1. determine the clustering resolution (number of clusters $k$ or resolution $r$)
  2. clustering with $k$-means or Louvain
  3. hierarchical organization of clusters (bubbles)
  4. visualization


### 1. determine the clustering resolution
If we intend to use the k-means clustering algorithm we first need to find an 
appropriate value of the number of clusters $k$. Alternatively, we can the
Louvain algorithm for clustering, in which case we need to find an appropriate 
value for the resolution parameter $r$.

#### 1.1 determining the number of clusters $k$
How many clusters (cell types) are there are in the data? Can we guess a 
reasonable value of $k$? 

We can study the literature or databases such as the human protein 
atlas database (HPA) to identify a range of reasonable $k$s. HPA provides a 
decomposition of PBMCs into 18 canonical cell populations[^3]. Given that here
we have about 162k PBMCs we might be able to recover all 18 subtypes, and hence
$k\approx18$ seems as a reasonable first choice.

We can also use the function `get_k` for data-driven estimation of $k$ based 
on the Gap statistic and the within-cluster sum of squares (WCSS).
  
Lets run `get_k` now

```{r, echo=F, eval = T, results='hide'}
rm(d)
gc();gc();gc();gc();gc();gc();
gc();gc();gc();gc();gc();gc();
save(A, file = "case_study_B/A.RData")
A <- get(load(file = "case_study_B/A.RData"))
```


```{r, fig.width=4, fig.height=3, echo = T, eval=F}
b_k <- get_k(ks = c(seq(from = 1, to = 50, by = 1), 51, 56, 72, 82, 97, 111),
             x = A,
             n_start = 100,
             iter_max = 200,
             kmeans_algorithm = "MacQueen",
             cores = 60,
             B_gap = 20)
```


```{r, fig.width=4, fig.height=3, echo = F, eval = T}
if(redo_case_b) {
  b_k <- get_k(ks = c(seq(from = 1, to = 50, by = 1), 51, 56, 72, 82, 97, 111),
               x = A,
               n_start = 100,
               iter_max = 200,
               kmeans_algorithm = "MacQueen",
               cores = 60,
               B_gap = 20)
  
  if(dir.exists("case_study_B")==F) {
    dir.create("case_study_B")
  }
  save(b_k, file = "case_study_B/b_k.RData")
  cat("Done.")
} else {
  b_k <- get(load("~/scBubbletree/case_study_B/b_k.RData"))
}

```


The Gap statistic curve and the WCSS curve appear to follow three general 
regimes. In the first regime we see a steep increase in the Gap statistic and 
a steep decrease in WCSS for values of $k$ between 1 and 6 (approximately the 
number of major PBMC subtypes). 

Second, between $k\approx7$ and $k\approx16$ both curves follow similar trends 
as before but have smaller slopes, i.e. the change in the Gap statistic and 
WCSS as a function of $k$ is smaller in the second regime. 

Third, both curves level off around $k\approx16$, and incremental increase 
in $k$ beyond this point results in negligible changes in either metric. 

In summary, the Gap statistic and WCSS curves are consistent with our prior 
knowledge about PBMCs, i.e. at $k\approx16$ most of the canonical PBMC cell 
populations are likely to have been recovered, and there appears to be little 
benefit in using larger values of $k$. 


```{r, echo = T, eval = T}
g0_k <- ggplot(data = b_k$gap_stats_summary)+
  geom_point(aes(x = k, y = gap_mean), size = 1)+
  geom_errorbar(aes(x = k, y = gap_mean, ymin = L95, ymax = H95), width = 0.1)+
  ylab(label = "Gap")|
ggplot(data = b_k$wcss_stats_summary)+
  geom_point(aes(x = k, y = wcss_mean), size = 1)+
  ylab(label = "WCSS")+
  scale_y_log10()+
  annotation_logticks(base = 10, sides = "l")
```


```{r, echo = T, eval = T, fig.width=7, fig.height=3, fig.align='center'}
g0_k
```


#### 1.2 determining the resolution parameter $r$
For Louvain clustering we need to select a clustering resolution $r$. Higher 
resolutions lead to more communities and lower resolutions lead to fewer 
communities. We can use the same strategy as before to find a reasonable 
value of $r$.

Lets use the function `get_r` for data-driven estimation of $r$ based on the
Gap statistic and WCSS. As input we need to provide the matrix $A$ and a vector 
of $r$s. As output we will get Gap statistic and WCSS estimates for each $r$ 
(or the number of communities $k$ detected at each resolution $r$).

```{r, echo = T, eval = F}
b_r <- get_r(B_gap = 20,
             rs = 10^seq(from = -4, to = 1, by = 0.1),
             x = A,
             n_start = 20, 
             iter_max = 100,
             louvain_algorithm = "original",
             cores = 10)
```


```{r, fig.width=4, fig.height=3, echo = F, eval = T}
if(redo_case_b) {
  b_r <- get_r(B_gap = 20,
               rs = 10^seq(from = -4, to = 1, by = 0.1),
               x = A,
               n_start = 20, 
               iter_max = 100,
               louvain_algorithm = "original",
               cores = 80)
  
  if(dir.exists("case_study_B")==F) {
    dir.create("case_study_B")
  }
  save(b_r, file = "case_study_B/b_r.RData")
  cat("Done.")
} else {
  b_r <- get(load("case_study_B/b_r.RData"))
}

```




```{r, echo=T, eval=T}
g0_r <- ggplot(data = b_r$gap_stats_summary)+
  geom_point(aes(x = k, y = gap_mean), size = 1)+
  geom_point(data = b_r$gap_stats_summary[b_r$gap_stats_summary$k == 24,],
             aes(x = k, y = gap_mean), size = 3, shape = 21, col = "red")+
  geom_errorbar(aes(x = k, y = gap_mean, ymin = L95, ymax = H95), width = 0.1)+
  ylab(label = "Gap")|
ggplot(data = b_r$wcss_stats_summary)+
  geom_point(aes(x = k, y = wcss_mean), size = 1)+
  geom_point(data = b_r$wcss_stats_summary[b_r$wcss_stats_summary$k == 24,],
             aes(x = k, y = wcss_mean), size = 3, shape = 21, col = "red")+
  ylab(label = "WCSS")+
  scale_y_log10()+
  annotation_logticks(base = 10, sides = "l")
```


We see a soft elbow at $k\approx24$ (red hollow points) in the Gap statistic 
and WCSS curves. In fact, the $\Delta$ in the Gap statistic between $k=22$ and 
$k=24$ is roughly equal to the $\Delta$ between $k=24$ and $k=72$. Means 
(points) and 95% confidence intervals are shown for the Gap statistic at each 
$k$ computed using `B_gap`=20 MCMC simulations. 

In summary, the Louvain algorithm suggests slightly higher $k$ than k-means.
We get $k=24$ with resolution parameter $r\approx0.79$, which is the default 
setting of $r$ used by the Seurat R-package.

Importantly, the final choice of $k$ also depends on the intent of the 
researcher and on the design of the experiment. Given that dataset B was 
generated at high throughput and consists of over 161,000 cells, we decided 
to use $k=24$ for the clustering step as this would enable us to recover the 
canonical PBMC subtypes.


```{r, fig.width=7, fig.height=2.5, fig.align='center', echo=T, eval=T}
g0_r
```


Table with Gap statistic estimates and ($k$, $r$) pairs:

```{r}
knitr::kable(x = b_r$gap_stats_summary,
             digits = 3, row.names = F)
```






#### 2 with Louvain
For complex datasets it has been shown graph based methods for community 
detection have a higher power of detecting rare and common clusters of cells 
than k-means. Hence in the next we will proceed with Louvain clustering 
(R-package Seurat) with $r=0.79$.

There are numerous variants of the Louvain algorithm. Here we will use the 
original implementation. We will do clustering with $n_{start} = 20$ random 
starts and a maximum number of iterations $iter_{max} = 100$. 

### 3. hierarchical grouping
After the clustering is complete we will organize the bubbles in a natural
hierarchy. We will use $B=200$ bootstrap iterations. In iteration $b$ the 
algorithm will draw $N_{eff}=200$ cells with replacement from each cluster 
and compute the average inter-cluster Euclidean distances. This data is used 
to populate the distance matrix ($D^{k\times k}_b$), which is provided as 
input for hierarchical clustering with average linkage to generate a 
hierarchical clustering dendrogram $H_b$. 

The collection of distance matrices that are computed during $B$ 
iterations are used to compute a consensus (average) distance matrix 
($\hat{D}^{k\times k}$) and a corresponding consensus hierarchical 
dendrogram (bubbletree; $\hat{H}$). The collection of dendrograms 
are used to quantify the robustness of the bubbletree topology, i.e.
to count the number of times each branch in the bubbletree is found 
among the topologies of the bootstrap dendrograms. Branches can have 
has variable degrees of support ranging between 0 (no support) and $B$ 
(complete support). Distances between bubbles (inter-bubble relationships) 
are described quantitatively in the bubbletree as sums of branch lengths. 

Steps 2. and 3. are performed next


```{r, echo=T, eval=F}
k24_louvain <- get_bubbletree_louvain(x = A,
                                      r = 0.79,
                                      n_start = 20,
                                      iter_max = 100,
                                      louvain_algorithm = "original",
                                      seed = 1234,
                                      cores = 5,
                                      B = 200,
                                      N_eff = 200,
                                      round_digits = 1,
                                      show_simple_count = T)
```


```{r, echo=F}

if(redo_case_b) {
  
  k24_louvain <- get_bubbletree_louvain(x = A,
                                        r = 0.79,
                                        n_start = 20,
                                        iter_max = 100,
                                        louvain_algorithm = "original",
                                        seed = 1234,
                                        cores = 5,
                                        B = 200,
                                        N_eff = 200,
                                        round_digits = 1,
                                        show_simple_count = F)
  
  if(dir.exists("case_study_B")==F) {
    dir.create("case_study_B")
  }
  save(k24_louvain, file = "case_study_B/k24_louvain.RData")
} else {
  k24_louvain <- get(load("~/scBubbletree/case_study_B/k24_louvain.RData"))
}


```










```{r, echo=F}

if(redo_case_b) {
  
  k24_kmeans <- get_bubbletree_kmeans(x = A,
                                      k = 24,
                                      kmeans_algorithm = "MacQueen",
                                      seed = 1234,
                                      cores = 5,
                                      B = 200,
                                      N_eff = 200,
                                      round_digits = 1,
                                      show_simple_count = F)
  
  if(dir.exists("case_study_B")==F) {
    dir.create("case_study_B")
  }
  save(k24_kmeans, file = "case_study_B/k24_kmeans.RData")
} else {
  k24_kmeans <- get(load("~/scBubbletree/case_study_B/k24_kmeans.RData"))
}


```









... and plot the bubbletree

```{r, fig.width=4, fig.height=6, fig.align='center', echo=T}
k24_louvain$tree
```

Lets describe the bubbletree:

**bubbles**: The bubbletree has `k=24` bubbles (clusters) shown as leaves. 
The absolute and relative cell frequencies in each bubble and the bubble 
IDs are shown as labels. Bubble radii are scaled linearly as the absolute 
cell count in each bubble, i.e. large bubbles have many cells and small
bubbles contain few cells. 

Bubble 14 is remarkably large as it contains about 33,100 (19.2% of the cells 
in the dataset). In contrast to this, bubbles 9, 13, 5 and 17 are small as 
they contained between 600 (0.4%) and 1,300 (0.8%) cells. The remaining 
bubbles contained between 2,700 (1.7%) and 15,900 (9.8%) cells, and had small 
to medium sizes.

We can access the bubble data shown in the bubbletree

```{r, echo=T, results=T}
knitr::kable(k24_louvain$tree_meta, digits = 2, row.names = F)
```


**topology**: inter-bubble distances are represented by sums of the 
corresponding branch lengths in the dendrogram. 

The topology of the bubbletree contained two major clades. The top clade 
consists of ten bubbles (19, 11, 14, 8, 6, 16, 3, 4, 15, 10), which 
collectively account for about 65% of the cells in the sample. The bottom 
clade contained six bubbles (18, 12, 20, 1, 2, 7), which contained about 32% 
of the sample cells. Judged alone from the relative frequencies of the cells
in each clade, we predicted that the top clade is enriched with lymphocytes 
(the most dominant PBMC subtype) and the bottom clade by monocytes. The 
remaining bubbles 17, 5, 13 and 9 were shown as an outgroup and accounted 
for less than 3% of the cells in the dataset. All branches of the bubbletree 
are robust, except for the branch joining bubble 19 and 11, which is found 
in 170 (85%) out of 200 bootstrap dendrograms. 

Biological interpretation of the different clades and their complex within-
clade branching patterns are provided in the following.


### 4. visualization

#### attaching categorical cell features
We will visualize the relative frequencies of categorical cell features 
including: 
  
  * cell type annotations *l1* and *l2*
  * donor (sample) IDs
  
```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
c1 <- meta$celltype.l1
c2 <- gsub(pattern = "Proliferating", replacement = 'prolif.', meta$celltype.l2)
c2 <- gsub(pattern = "CD56bright", replacement = 'CD56', x = c2)
donor <- paste0(meta$donor, '(', meta$time, ')')
```


```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
w0_v <- get_cat_tiles(btd = k24_louvain,
                      f = c1,
                      integrate_vertical = T,
                      round_digits = 0,
                      show_hclust = F,
                      tile_text_size = 2.75,
                      disable_hclust = F,
                      x_axis_name = 'Cell type (l1)')


w0_h <- get_cat_tiles(btd = k24_louvain,
                      f = c1,
                      integrate_vertical = F,
                      round_digits = 0,
                      show_hclust = F,
                      tile_text_size = 2.75,
                      disable_hclust = F,
                      x_axis_name = 'Cell type (l1)')
```


```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
w1_v <- get_cat_tiles(btd = k24_louvain,
                      f = c2,
                      integrate_vertical = T,
                      round_digits = 0,
                      show_hclust = F,
                      tile_text_size = 2.75,
                      disable_hclust = F,
                      x_axis_name = 'Cell type (l2)')

w1_h <- get_cat_tiles(btd = k24_louvain,
                      f = c2,
                      integrate_vertical = F,
                      round_digits = 0,
                      show_hclust = F,
                      tile_text_size = 2.75,
                      disable_hclust = F,
                      x_axis_name = 'Cell type (l2)')
```


```{r, fig.width=9, fig.height=5, fig.align='center', echo=T}
w2 <- get_cat_tiles(btd = k24_louvain,
                    f = donor,
                    integrate_vertical = T,
                    round_digits = 0,
                    show_hclust = F,
                    tile_text_size = 2.75,
                    disable_hclust = T,
                    x_axis_name = 'Donor')
```




```{r, echo=T, results='hide'}
fig_l0 <- g0_r

fig_l1 <- (k24_louvain$tree|w0_v$plot|w0_h$plot)+
  patchwork::plot_layout(widths = c(2, 3, 3))

fig_l2 <- (k24_louvain$tree|w1_v$plot|w1_h$plot)+
  patchwork::plot_layout(widths = c(2, 3, 3))

fig <- (fig_l0/fig_l1/fig_l2)+
  patchwork::plot_annotation(tag_levels = 'A')+
  patchwork::plot_layout(heights = c(1, 2, 2))

rm(fig_l0, fig_l1, fig_l2)
```



```{r, fig.width=16, fig.height=15}
fig
```


#### attaching numeric cell features

Lets visualize the average gene expression of 
some marker genes in the bubbles:

  * GNLY, NKG7:	*NK cells*
  * IL7R:	*CD4 T cells*
  * CD8A:	*CD8 T cells*
  * MS4A1:	*B cells*
  * CD14, LYZ:	*CD14+ Monocytes*
  * FCGR3A, MS4A7:	*FCGR3A+ Monocytes*
  * FCER1A, CST3:	*Dendritic Cells*
  * PPBP:	*Megakaryocytes*

```{r, fig.width=8, fig.height=8, fig.align='center', echo=T}
fig_markers <- get_num_tiles(btd = k24_louvain,
                             fs = as,
                             summary_function = "mean",
                             round_digits = 1,
                             show_hclust = F,
                             disable_hclust = T,
                             x_axis_name = "Gene expression",
                             rotate_x_axis_labels = T)

(k24_louvain$tree|fig_markers$plot)+
  patchwork::plot_layout(widths = c(1, 1))
```

Second, we can visualize the distribution of each marker gene in each 
bubble using violin plots with `get_num_violins`. This function uses 
the same input as `get_num_tiles`. 

Lets invoke this function now.

```{r, fig.width=8, fig.height=14, fig.align='center', echo=T}
fig_markers_violin <- get_num_violins(btd = k24_louvain,
                      fs = as,
                      x_axis_name = "Gene expression",
                      rotate_x_axis_labels = T)


((k24_louvain$tree|fig_markers$plot)+
    patchwork::plot_layout(widths = c(1, 1)))/
  fig_markers_violin$plot
```



### quality control with `scBubbletree`

```{r, echo = F, fig.align='center', fig.width=7, fig.height=6}
sup_w <- (get_num_violins(btd = k24_louvain,
                          fs = meta$mt*100,
                          x_axis_name = "MT [%]",
                          rotate_x_axis_labels = F)$plot|
            get_num_violins(btd = k24_louvain,
                            fs = meta$nCount_RNA/1000,
                            x_axis_name = "RNA count (in thousands)",
                            rotate_x_axis_labels = F)$plot|
            get_num_violins(btd = k24_louvain,
                            fs = meta$nFeature_RNA,
                            x_axis_name = "Gene count",
                            rotate_x_axis_labels = F)$plot
)

sup_w
```

Interestingly, the bubbles 1 and 2 contain many different cell types. 
Additional clustering of these bubbles might be necessary.



### bubble purity assessment based on Gini impurity index
Can we show quantitatively that by increasing `k` we get "better" 
clustering in a semi-supervised way? Yes, we can use the Gini impurity 
index.

For this we will integrate the results obtained by function `get_k` 
with *l1*, *l2* and *l3* cell type predictions (labels), and show 
quantitatively the change in Gini index as a function of `k`. This 
is done with the function `get_gini_k`. One potential caveat of this 
approach is that some of the predictions might be inaccurate. 

Lets invoke the function `get_gini_k` and pass the object `b` obtained 
earlier together with the cell type predictions:

```{r, echo = T}
gini_l1 <- get_gini_k(labels = meta$celltype.l1,
                      obj = b_r)
gini_l2 <- get_gini_k(labels = meta$celltype.l2,
                      obj = b_r)
gini_l3 <- get_gini_k(labels = meta$celltype.l3,
                      obj = b_r)
```


We next plot the Gini scores for the labels at resolution *l1*, *l2* and *l3*.

Summary of the plot:
More abstract cell types can be segmented more accurately and the resulting 
segmentation has lower total Gini impurity. In each curve the total Gini 
impurity appears to decrease slowly for as $k$ approaches 20. This indicates 
that our previous data-based indices provide meaningful results.

```{r, fig.width=5, fig.height=4, fig.align='center'}
l1 <- gini_l1$wgi_summary
l1$level <- "l1"

l2 <- gini_l2$wgi_summary
l2$level <- "l2"

l3 <- gini_l3$wgi_summary
l3$level <- "l3"

l_summary <- rbind(l1, l2, l3)

g_gini <- ggplot(data = l_summary)+
  geom_point(aes(x = k, y = wgi, col = level, shape = level), 
             size = 1)+
  scale_color_manual(name = "R",
                     values = c("black", "#787777", "gray"))+
  scale_shape_manual(name = "R", values = c(1, 2, 3))+
  theme(legend.position = "top")+
  ylab(label = "Gini impurity")+
  ylim(c(0,1))+
  xlab(label = "k-means clusters (k)")+
  xlim(c(0, 50))

g_gini
```





## Are local/global distances between cells preserved by UMAP/t-SNE?

Local cell distances appear to be adequatly recovered, long-range distances 
are not. Gray points are intra-bubble distances and black points are 
inter-bubble distances.

```{r, echo = T, results='hide'}

get_euc_dist <- function(x, pairs, m) {
  
  get_euc <- function(x, y) {
    return(sqrt(sum((x-y)^2)))
  }
  
  i <- pairs[x,1]
  j <- pairs[x,2]

  return(sqrt(sum((m[i,]-m[j,])^2))) 
}


pairs <- t(replicate(n = 5*10^4, sample(x = 1:nrow(A), size = 2)))

i_cell <- meta$celltype.l2[pairs[, 1]]
j_cell <- meta$celltype.l2[pairs[, 2]]
comparison <- ifelse(test = i_cell==j_cell, yes = "w", no = "b")

```


```{r, echo = F}
d <- get(load(file = "case_study_B/Hao_2021.RData"))
```


```{r, echo = T, results='hide'}
euc_a <- lapply(X = 1:nrow(pairs), pairs = pairs, 
                m = A, FUN = get_euc_dist)

euc_u <- lapply(X = 1:nrow(pairs), pairs = pairs, 
                m = d@reductions$umap@cell.embeddings[, c("UMAP_1", "UMAP_2")], 
                FUN = get_euc_dist)

euc_t <- lapply(X = 1:nrow(pairs), pairs = pairs, 
                m = d@reductions$tsne@cell.embeddings[, c("tSNE_1", "tSNE_2")], 
                FUN = get_euc_dist)

# memory issue
x <- d@assays$SCT@data[, sort(unique(as.vector(pairs)), decreasing = T)]
x <- as.matrix(x)
x <- t(x)
rownames(x) <- sort(unique(as.vector(pairs)), decreasing = T)
r_x <- rownames(x)
euc_x <- numeric(length = length(euc_a))
for(i in 1:nrow(pairs)) {
  euc_x[i] <- sqrt(sum((x[which(r_x == pairs[i, 1]),]-
                          x[which(r_x == pairs[i, 2]),])^2))
  
}

dist_preservation <- data.frame(euc_a = unlist(euc_a), 
                                euc_u = unlist(euc_u), 
                                euc_t = unlist(euc_t), 
                                euc_x = unlist(euc_x),
                                i = i_cell, 
                                j = j_cell, 
                                comparison = comparison)

save(dist_preservation, file = "case_study_B/dist_preservation.RData")
```






```{r, fig.width=8, fig.height=4, fig.align='center', echo = T}
g_pairs_umap_tsne <- ggplot(data = dist_preservation)+
  geom_point(aes(y = euc_a, x = euc_u, col = comparison), size = 0.25)+
  geom_density_2d(aes(y = euc_a, x = euc_u), col = "orange")+
  ylab(label = "Distance [PCA]")+
  xlab(label = "Distance [2D UMAP]")+
  scale_color_manual(values = c("black", "darkgray"))+
  theme(legend.position = "none")|
ggplot(data = dist_preservation)+
  geom_point(aes(y = euc_a, x = euc_t, col = comparison), size = 0.25)+
  geom_density_2d(aes(y = euc_a, x = euc_t), col = "orange")+
  ylab(label = "Distance [PCA]")+
  xlab(label = "Distance [2D t-SNE]")+
  scale_color_manual(values = c("black", "darkgray"))+
  theme(legend.position = "none")

g_pairs_umap_tsne
```



```{r, echo=F}
# save image
save.image(file = "case_study_B/workspace_image.RData")
```





```{r, echo=F}
# save image

key_results <- list(b_r = b_r,
                    b_k = b_k,
                    k24_louvain = k24_louvain,
                    k24_kmeans = k24_kmeans,
                    dist_preservation = dist_preservation,
                    meta = meta)

save(key_results, file = "case_study_B/key_results.RData")

```



# References

[^1]: Hao, Yuhan, et al. "Integrated analysis of multimodal single-cell 
data." Cell 184.13 (2021): 3573-3587.
[^2]: https://satijalab.org/seurat/articles/multimodal_reference_mapping.html
[^3]: https://www.proteinatlas.org/humanproteome/immune+cell
