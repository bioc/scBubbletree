---
title: "Case study E: Exploring scRNA-seq data from 2,700 PBMCs with scBubbletree"
author: "SK"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---


```{r}
source(file = "~/Rutil/Init_Rpack.R")
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = F,
                      comment = F, 
                      warning = F, 
                      message = F)
```


This vignette introduces `scBubbletree`, a transparent workflow for exploration
of single cell RNA-seq data. To run this vignette we need a few R-packages:


```{r, echo = T, eval = F, results='hide'}
library(scBubbletree)
library(Seurat)
library(ggrepel)
```


```{r, echo = F, results='hide'}
library(scBubbletree)
library(Seurat, lib.loc = lib.loc)
library(ggrepel, lib.loc = lib.loc)
```


```{r, echo=F}
redo_case_a <- F
```





## Data

Here we will analyze a scRNA-seq sample of 2,700 PBMCs freely available from 
10X genomics and sequenced with Illumina NextSeq 500. The dataset is available 
here[^1]. 

```{r, echo=T, eval = F, results='hide'}
# create directory
dir.create(path = "case_study_E/")


# download the data from: 
# https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz


# load the data
pbmc <- Read10X(data.dir = "case_study_E/filtered_gene_bc_matrices/hg19/")


# create seurat object
pbmc <- CreateSeuratObject(counts = pbmc, 
                           project = "pbmc3k", 
                           min.cells = 3, 
                           min.features = 200)


# compute % of UMIs from mitochondrial genes
pbmc[["percent.mt"]] <- PercentageFeatureSet(object = pbmc, 
                                             pattern = "^MT-")


# log normaliza data
pbmc <- NormalizeData(object = pbmc, 
                      normalization.method = "LogNormalize", 
                      scale.factor = 10000)


# select 5,000 most variable genes
pbmc <- FindVariableFeatures(object = pbmc, 
                             selection.method = "vst", 
                             nfeatures = 5000)

# center + scale data
pbmc <- ScaleData(object = pbmc, 
                  features = rownames(pbmc))

# run PCA
pbmc <- RunPCA(object = pbmc, 
               features = VariableFeatures(object = pbmc),
               npcs = 50)


# UMAP + t-SNE dimensionality reduction
pbmc <- RunUMAP(object = pbmc, 
                dims = 1:15)
pbmc <- RunTSNE(object = pbmc, 
                dims = 1:15)

save(pbmc, file = "case_study_E/pbmc.RData")
```



```{r}
# load Seurat object
pbmc <- get(load(file = "case_study_E/pbmc.RData"))
```



## scBubbletree
   
We will analyze this data with `scBubbletree`. 

As first input `scBubbletree` uses matrix $A^{n\times f}$ which represents a 
low-dimensional projection of the original scRNA-seq data, with $n$ rows as 
cells and $f$ columns as low-dimension features. 

We will use the PCA data generated by `Seurat` as $A$. In particular, we will 
use the first 15 principal components (PCs) as every additional PC explains 
negligible amount of variance in the data.

```{r, fig.width=4, fig.height=3, echo=T, fig.align='center'}
var_explained <- ((pbmc[["pca"]]@stdev)^2)/pbmc[["pca"]]@misc$total.variance

g_var_explained <- ggplot(data = data.frame(var_explained = var_explained*100,
                                            PC = 1:length(var_explained)))+
  geom_point(aes(y = var_explained, x = PC), size = 1)+
  ylab(label = "Variance explained [%]")

g_var_explained
```

```{r, echo = T}
# This is the main input of scBubbletree -> matrix A
A <- pbmc@reductions$pca@cell.embeddings[, 1:15]

# A has n=cells as rows, f=features as columns (e.g. from PCA)
dim(A)
```


The `scBubbletree` workflow performs the following steps:
  
  1. determine number of clusters $k$
  2. $k$-means clustering
  3. hierarchical organization of clusters (bubbles)
  4. annotation and evaluation


### 1. determining the number of clusters $k$
How many clusters (cell types) are there are in the data? C we guess a 
reasonable value of $k$? 

Two approaches should be used to find $k$. 

First, we need to study the literature or databases such as the human protein 
atlas database (HPA) to identify a reasonable range of $k$s. HPA provides a 
decomposition of PBMCs into 18 canonical cell populations[^2]. Given that here 
we have only 2,700 PBMCs it might be unrealistic to recover all 18 subtypes, 
however, this gives us an idea about the general range of useful $k$s.

Second, we can use the function `get_k` for data-driven inference of $k$ based 
on the Gap statistic and the within-cluster sum of squares (WCSS).
  
Lets run `get_k` now:

```{r, echo = T, eval = T}
b <- get_k(B = 5, # number of bootstrap iterations  
           cv_prop = 1, # use 100% of the rows (cells) in A in each iteration
           ks = seq(from = 1, to = 40, by = 2), # ks to test
           x = A, # main input A
           n_start = 100,  # number of starts in k-means
           iter_max = 200, # maximum number of iterations in k-means
           kmeans_algorithm = "MacQueen",  # k-means variant
           cores = 20) # number of cores
```


The Gap statistic and WCSS curves have a noticeable knee (elbow) at $k\approx11$. 
Hence, $k$=11 appears to be reasonable first choice of $k$. Means and 95% 
confidence intervals are shown for the metrics (panels) at each $k$.

```{r, echo=T, eval=T}
g0 <- ggplot(data = b$gap_stats_summary)+
  geom_point(aes(x = k, y = gap_mean), size = 1)+
  geom_errorbar(aes(x = k, y = gap_mean, ymin = L95, ymax = H95), width = 0.1)+
  ylab(label = "Gap")|
ggplot(data = b$wcss_stats_summary)+
  geom_point(aes(x = k, y = wcss_mean), size = 1)+
  geom_errorbar(aes(x = k, y = wcss_mean, ymin = L95, ymax = H95), width = 0.1)+
  ylab(label = "WCSS")+
  scale_y_log10()+
  annotation_logticks(base = 10, sides = "l")
```


```{r, fig.width=7, fig.height=2.5, fig.align='center', echo=T, eval=T}
g0
```


### 2. $k$-means clustering
Now that we found out that $k=11$ is reasonable we will perform clustering with
$k=11$ and $A$ as inputs. We use the function kmeans (R-package stats) which 
offers various k-means variants. Here we will use MacQueen's k-means variant, 
which will perform $n_{start} = 1000$ (default in scBubbletree) random starts 
and a maximum number of iterations $iter_{max} = 300$. 

### 3. hierarchical grouping
After the clustering is complete we will organize the bubbles in a natural
hierarchy. We will use $B=200$ bootstrap iterations. In iteration $b$ the 
algorithm will draw $N_{eff}=200$ cells with replacement from each cluster and 
compute the average inter-cluster Euclidean distances. This data is used to 
populate the distance matrix ($D^{k\times k}_b$), which is provided as input 
for hierarchical clustering with average linkage to generate a hierarchical 
clustering dendrogram $H_b$. 

The collection of distance matrices that are computed during $B$ iterations are 
used to compute a consensus (average) distance matrix ($\hat{D}^{k\times k}$) 
and a corresponding consensus hierarchical dendrogram (bubbletree; $\hat{H}$). 
The collection of dendrograms are used to quantify the robustness of the 
bubbletree topology, i.e. to count the number of times each branch in the 
bubbletree is found among the topologies of the bootstrap dendrograms. Branches 
can have has variable degrees of support ranging between 0 (no support) and $B$ 
(complete support). Distances between bubbles (inter-bubble relationships) are 
described quantitatively in the bubbletree as sums of branch lengths. 

Steps 2. and 3. are performed next

```{r, echo=T, eval=T}
k11 <- get_bubbletree(x = A, # main input
                       k = 11, # number of clusters
                       seed = 1234, # seed for reproducible results
                       cores = 1, # number of cores
                       B = 200, # number of bootstraps
                       N_eff = 200, # number of cells for distance comp.
                       round_digits = 1, # rounding relative frequencies
                       show_simple_count = F, # divide bubble counts by 1,000?
                       kmeans_algorithm = "MacQueen") # k-means variant
```




... and plot the bubbletree

```{r, fig.width=4, fig.height=4, fig.align='center', echo=T}
k11$tree
```


Lets describe the bubbletree:

**bubbles**: The bubbletree has `k=11` bubbles (clusters) shown as leaves. The 
absolute and relative cell frequencies in each bubble and the bubble IDs are 
shown as labels. Bubble radii and color-code represent cell count in each 
bubble, i.e. large & dark bubbles have many cells and small & light bubbles 
contain few cells. 

Bubbles 2 and 9 are large and dark 630 (23.3%) and 551(20.4%) of the sample 
cells, respectively. Bubbles 5 and 3 are small and white and contain 7 (0.3%) 
and 13 (0.5%) of the sample cells, respectively.

We can access the bubble data shown in the bubbletree

```{r, echo=T, results=T}
knitr::kable(k11$tree_meta, digits = 2, row.names = F)
```

**topology**: inter-bubble distances are represented by sums of the 
corresponding branch lengths in the dendrogram. 

We see two pronounced **clades**, which likely belong to the subtypes of 
lymphocytes and monocytes. We will prove this later on by 'attaching' 
annotations to the bubbletree.

Branches of the bubbletree are annotated with their bootstrap support values 
(red branch labels). The branch support value tells us how many times a given 
branch from the bubbletree was found among the $B$ bootstrap dendrograms. We 
called `get_bubbletree` with $B=200$. All branches have complete (200 out of 
200) support $\rightarrow$ robust branches.


### 4. annotation and evaluation

Lets "attach" numeric cell features to the bubbletree. We will "attach" 
the expression of different marker genes of PBMC subtypes.

  * IL7R, CCR7 (**Naive CD4+ T**)
  * CD14, LYZ	(**CD14+  Mono**)
  * IL7R, S100A4 (**Memory CD4+**)
  * MS4A1	(**B**)
  * CD8A (**CD8+ T**)
  * FCGR3A, MS4A7 (**FCGR3A+ Mono**)
  * GNLY, NKG7 (**NK**)
  * FCER1A, CST3 (**DC**)
  * PPBP (**Platelet**)

```{r, echo=T}
fs <- t(as.matrix(pbmc@assays$RNA@data[
  rownames(pbmc@assays$RNA@data) %in% 
    c("IL7R", 
      "CD14", "LYZ", 
      "MS4A1", 
      "CD8A", 
      "GNLY", "NKG7",
      "FCGR3A", "MS4A7",
      "FCER1A", "CST3",
      "PPBP"), ]))

```


We can visualize numeric features in *two* ways.

First, we can show average numeric features in the different bubbles 
with `get_num_tiles`. 

Indeed, the top clade contains lymphocytes, the bottom clade contains monocytes 
and DCs, and the outgroup bubbles (6 and 12) have high expression of PPBP 
(platelet marker). Bubble 3 expresses markers of proliferating lymphocytes.

```{r, fig.width=9, fig.height=4.5, fig.align='center', echo=T}
w1 <- get_num_tiles(btd = k11,
                    fs = fs,
                    summary_function = "mean",
                    show_hclust = F,
                    disable_hclust = F,
                    x_axis_name = 'Gene expression',
                    rotate_x_axis_labels = T,
                    round_digits = 1,
                    tile_text_size = 2.75)

(k11$tree|w1$plot)+
  patchwork::plot_layout(widths = c(1, 1))
```

Second, we can visualize the distributions of the numeric cell features in each
bubble as violins with `get_num_violins`

```{r, fig.width=10, fig.height=4.5, fig.align='center', echo=T}
w2 <- get_num_violins(btd = k11,
                      fs = fs,
                      x_axis_name = 'Gene expression',
                      rotate_x_axis_labels = T)

(k11$tree|w2$plot)+
  patchwork::plot_layout(widths = c(1, 3))
```

### quality control with `scBubbletree`

What is the percent of UMIs coming from mitochondrial genes in each bubble? 

```{r, fig.width=10, fig.height=4.5, fig.align='center', echo=T}
w_mt_dist <- get_num_violins(btd = k11,
                             fs = pbmc@meta.data$percent.mt,
                             x_axis_name = 'MT [%]',
                             rotate_x_axis_labels = T)

w_umi_dist <- get_num_violins(btd = k11,
                              fs = pbmc@meta.data$nCount_RNA/1000,
                              x_axis_name = 'RNA count (in thousands)',
                              rotate_x_axis_labels = T)

w_gene_dist <- get_num_violins(btd = k11,
                               fs = pbmc@meta.data$nFeature_RNA,
                               x_axis_name = 'Gene count',
                               rotate_x_axis_labels = T)


(k11$tree|w_mt_dist$plot|w_umi_dist$plot|w_gene_dist$plot)+
  patchwork::plot_layout(widths = c(1, 1, 1, 1))+
  patchwork::plot_annotation(tag_levels = 'A')
```





## UMAP and t-SNE

Generating 2D UMAP and t-SNE plots is a standard first step in scRNA-seq data 
analysis. Lets do this now:

```{r, fig.width=8, fig.height=3.25, fig.align='center', echo = T}
pbmc@meta.data$bubble <- as.character(k11$cluster)

umap_data <- cbind(pbmc@meta.data, pbmc@reductions$umap@cell.embeddings)
umap_data$closest_cluster <- NA
umap_centers <- merge(x = aggregate(UMAP_1~bubble, 
                                    data = umap_data, FUN = median),
                      y = aggregate(UMAP_2~bubble, 
                                    data = umap_data, FUN = median),
                      by = "bubble")


tsne_data <- cbind(pbmc@meta.data, pbmc@reductions$tsne@cell.embeddings)
tsne_data$closest_cluster <- NA
tsne_centers <- merge(x = aggregate(tSNE_1~bubble, 
                                    data = tsne_data, FUN = median),
                      y = aggregate(tSNE_2~bubble, 
                                    data = tsne_data, FUN = median),
                      by = "bubble")
```


```{r, fig.width=8, fig.height=3.25, fig.align='center', echo = T}
g_umap_tsne <- ggplot()+
  geom_point(data = umap_data,
             aes(x = UMAP_1, y = UMAP_2, col = bubble), size = 0.25)+
  geom_text_repel(data = umap_centers,
            aes(x = UMAP_1, y = UMAP_2, label = bubble), 
            min.segment.length = 0, size = 3)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))|
  ggplot()+
  geom_point(data = tsne_data,
             aes(x = tSNE_1, y = tSNE_2, col = bubble), size = 0.25)+
  geom_text_repel(data = tsne_centers,
            aes(x = tSNE_1, y = tSNE_2, label = bubble), 
            min.segment.length = 0, size = 3)+
  theme(legend.position = "none")+
  guides(colour = guide_legend(nrow = 4,
                               override.aes = list(size=2)))

g_umap_tsne
```



## Are local/global distances between cells preserved by UMAP/t-SNE?

Local cell distances appear to be adequatly recovered, long-range distances 
are not. Gray points are intra-bubble distances and black points are 
inter-bubble distances.

```{r, echo = T, results='hide'}

get_d <- function(A, U_A, T_A, B, verbose=F) {
  
  get_euc <- function(x, y) {
    return(sqrt(sum((x-y)^2)))
  }
  
  get_pair_euc <- function(x, A, U_A, T_A) {
    
    if(x %% 1000 == 0) {
      cat(x, "\n")
    }
    
    j <- sample(x = 1:nrow(A), size = 2, replace = T)
    a_euc <- get_euc(A[j[1],], A[j[2],])
    u_euc <- get_euc(U_A[j[1],], U_A[j[2],])
    t_euc <- get_euc(T_A[j[1],], T_A[j[2],])
    
    return(data.frame(a_euc = a_euc, 
                      u_euc = u_euc,
                      t_euc = t_euc,
                      i = j[1],
                      j = j[2]))
  }
  
  o <- lapply(X = 1:B, 
              FUN = get_pair_euc, 
              A = A, 
              U_A = U_A, 
              T_A = T_A)
  
  o <- do.call(rbind, o)
  return(o)
}

```


```{r, echo = T, results='hide'}

pair_dist <- get_d(B = 10^4,
                   A = A,
                   U_A = umap_data[, c("UMAP_1", "UMAP_2")],
                   T_A = tsne_data[, c("tSNE_1", "tSNE_2")],
                   verbose = F)

pair_dist$i_cell <- pbmc@meta.data$bubble[pair_dist$i]
pair_dist$j_cell <- pbmc@meta.data$bubble[pair_dist$j]
pair_dist$comparison <- ifelse(test = pair_dist$i_cell==pair_dist$j_cell, 
                               yes = "w", no = "b")
```





```{r, fig.width=8, fig.height=4, fig.align='center', echo = T}
g_pairs_umap_tsne <- ggplot(data = pair_dist)+
  geom_point(aes(y = a_euc, x = u_euc, col = comparison), size = 0.25)+
  geom_density_2d(aes(y = a_euc, x = u_euc), col = "orange")+
  ylab(label = "Distance [PCA]")+
  xlab(label = "Distance [2D UMAP]")+
  scale_color_manual(values = c("black", "darkgray"))+
  theme(legend.position = "none")|
ggplot(data = pair_dist)+
  geom_point(aes(y = a_euc, x = t_euc, col = comparison), size = 0.25)+
  geom_density_2d(aes(y = a_euc, x = t_euc), col = "orange")+
  ylab(label = "Distance [PCA]")+
  xlab(label = "Distance [2D t-SNE]")+
  scale_color_manual(values = c("black", "darkgray"))+
  theme(legend.position = "none")

g_pairs_umap_tsne
```






[^1]: https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz
[^2]: https://www.proteinatlas.org/humanproteome/immune+cell
